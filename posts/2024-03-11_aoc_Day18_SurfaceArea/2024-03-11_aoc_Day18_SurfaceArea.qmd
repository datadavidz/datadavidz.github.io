---
title: "Advent of Code Day 18: Surface Area of Lava Droplet"
date: 2024-03-11
execute: 
  cache: true
---
```{r}
#| echo: false
#| results: "hide"
#renv::use(lockfile = "renv.lock")
```

Calculate surface area of a lava droplet using a breadth-first search approach

## Introduction

This post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 18. Bits of lava are being ejected from a volcano and you are able to get a scan of a droplet.  The scan contains a 3D grid of 1x1x1 cubes to approximate the shape of the lava droplet.  The speed at which the droplet cools could determine whether it creates obsidian.  The cooling rate will depend upon the surface area of the droplet.  Surface area is determined by the number of exposed cube faces.

## Loading the input file

The input file contains a file where each line is a series of 3 numbers separated by a comma (e.g. "13, 6, 3").  The ```read_lines``` function from the ```readr``` package is used to read the input file.

```{r}
library(readr)
library(stringr)
library(collections)

filepath <- here::here("./posts/data/aoc/day18_input.txt") #
#filepath <- here::here("./posts/data/aoc/day18_test.txt") #

cubes <- read_lines(filepath, skip_empty_rows = TRUE)
```

## Part One

We are first asked to determine the number of cube faces which are not attached to other cubes.  This number can be calculated by first determining the total possible number of faces which is the total number of cubes multiplied by 6 since a cube has 6 faces.  For each cube, the coordinates for each face are determined.  If the face is adjacent to another cube, the face is not part of the surface area and subtracted from the total possible number of faces.

```{r}
#coordinate system can be viewed as lower left corner of cube
sides <- list(c(-1,  0,  0),
              c( 1,  0,  0),
              c( 0, -1,  0),
              c( 0,  1,  0),
              c( 0,  0, -1),
              c( 0,  0,  1))

#total possible side (face) count
sc <- length(cubes) * 6

for (cube in cubes) {
  temp <- as.integer(unlist(str_split(cube, ",")))

  for (side in sides) {
    ss <- str_c(temp + side, collapse = ",")
    # subtract from total possible if occupied by an adjacent cube
    if (ss %in% cubes) sc <- sc - 1
  }
}

sc
```
Part two:

```{r}
offsets <- list(c(-0.5,    0,    0),
                c( 0.5,    0,    0),
                c(   0, -0.5,    0),
                c(   0,  0.5,    0),
                c(   0,    0, -0.5),
                c(   0,    0,  0.5)) 
```

```{r}
mx <- my <- mz <- Inf
Mx <- My <- Mz <- -Inf

droplet <- list()
faces <- list()
n <- 0

for (cube in cubes) {
   n <- n + 1
   cell <- as.numeric(unlist(str_split(cube, ",")))
   if (sum(cell == c(4, 5 ,6)) == 3) print(n)
   droplet <- c(droplet, list(cell))
   
   mx <- min(mx, cell[1])
   my <- min(my, cell[2])
   mz <- min(mz, cell[3])
   
   Mx <- max(Mx, cell[1])
   My <- max(My, cell[2])
   Mz <- max(Mz, cell[3])
   
   for (offset in offsets) {
     k <-paste(cell[1] + offset[1], cell[2] + offset[2], cell[3] + offset[3], collapse = "")
     if (!(k %in% names(faces))) {
       faces[[k]] <- 0
     }
     faces[[k]] <- faces[[k]] + 1
   }
}
```

```{r}
mx <- mx - 1
my <- my - 1
mz <- mz - 1

Mx <- Mx + 1
My <- My + 1
Mz <- Mz + 1
```

Using deque with lists
```{r}
start <- Sys.time()
q <- deque(list(c(mx, my, mz)))
air <- list(c(mx, my, mz))

while (q$size() > 0) {
  coords <- unlist(q$popleft())

  for (d in offsets) {
    k <- c(coords[1] + d[1] * 2, coords[2] + d[2] * 2, coords[3] + d[3] * 2)
    
    if (!((mx <= k[1]) & (k[1] <= Mx) & (my <= k[2]) & (k[2] <= My) & (mz <= k[3]) & (k[3] <= Mz))) {
      next
    }
    
    if (sum(droplet %in% list(k)) > 0) next
    if (sum(air %in% list(k)) > 0) next
  
    air <- c(air, list(k))
    q$push(list(k))
  }
}
end <- Sys.time()
```
