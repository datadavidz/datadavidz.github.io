{
  "hash": "ff58dcac4be174456b707d175ddb8eee",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 12: Breadth-First Search\"\ndate: 2023-07-28\n---\n\n::: {.cell}\n\n:::\n\n\nFinding the best path using a breadth-first search algorithm.\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 12.  You need to find a path to a location at a higher elevation in order to contact the elves with your communication device.  You are able to use the device to get a height-map of the surrounding area which is in a similar format as shown below.\n\n```\nSabqponm\nabcryxxl\naccszExk\nacctuvwj\nabdefghi\n```\n\nIn this height-map, the lowest elevation is given by \"a\", the highest elevation is given by \"z\" and the intermediate elevations ascend in alphabetical order.  Your starting position is given by \"S\" and the goal is to reach \"E\".  You can only ascend at most one level in each step but you can descend more than one level.\n\n## Loading the input file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n\nfilepath <- here::here(\"./posts/data/aoc/day12_input.txt\")\n\ncommands <- readLines(filepath)\n\n#find the size of the map\nnum_rows <- length(commands)\nnum_cols <- nchar(commands[[1]])\n```\n:::\n\n\nThe height-map data is then parsed into a matrix using a similar approach as I used in [Day 8](https://datadavidz.github.io/posts/2023-05-17_aoc_Day08_Matrices/2023-05-17_aoc_Day08_Matrices.html) using the ```str_split_1``` function from the ```stringr``` package.\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_map <- character()\n\nfor (i in 1:length(commands)) {\n  raw_map <- c(raw_map, as.character(str_split_1(commands[i], \"\")))\n}\n\ncontour_map <- matrix(raw_map, nrow = num_rows, ncol = num_cols, byrow = TRUE)\n```\n:::\n\n\n## Part One: Find best path from Start to End\n\nWe can find the start and end points in the matrix using the ```which``` function.  Once the locations have been identified, we can convert the \"S\" to an \"a\" and \"E\" to a \"z\" to make the path finding code more straightforward.\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- which(contour_map == \"S\", arr.ind = T)\nend <- which(contour_map == \"E\", arr.ind = T)\n\ncontour_map[start[1], start[2]] <- \"a\"\ncontour_map[end[1], end[2]] <- \"z\"\n```\n:::\n\n\nA breadth-first search algorithm was used to find the best path.  A queue is used to store the active path end locations and the number of steps which have been traversed.  The key checks before adding a new path end to the queue are the following:\n\n- Check if new location is on the map\n- Check if new location has not already been visited\n- Check if new location is not more than 1 height difference from current location\n- Check if new location is already present in the queue\n\nIf all checks pass, the new path end location and distance is added to the queue as captured in the following function:\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_to_queue <- function(con_map, cur_loc, new_loc, queue) {\n  if (new_loc[1] < 1 | new_loc[1] > num_rows) {\n    #do nothing if off the map\n  } else if (new_loc[2] < 1 | new_loc[2] > num_cols) {\n    #do nothing if off the map\n  } else if (con_map[new_loc[1], new_loc[2]] == \"*\") {\n    #do nothing if already visited\n  } else if (match(con_map[new_loc[1], new_loc[2]], letters) - match(con_map[cur_loc[1], cur_loc[2]], letters) > 1) {\n    #do nothing if inaccessible\n  } else {\n    #add to queue\n    if (list(new_loc) %in% queue == FALSE){\n      queue <- c(queue, list(new_loc))\n    }\n  }\n  return(queue)\n}\n```\n:::\n\n\nBeginning at the start location, new points in each direction are checked with the ```add_to_queue``` function and added to the end of the queue if passing the checks.  The points are then iteratively checked until the end location is reached.  A while loop is used to continue this process until ```reached_end``` is TRUE.  A loop count was added for troubleshooting and keep the loop from running forever if the logic was not quite right.\n\n\n::: {.cell hash='2023-07-28_aoc_Day12_BreadthFirst_cache/html/unnamed-chunk-6_b3581e0bc28dedc34fe54eaf62fd1d57'}\n\n```{.r .cell-code}\n#initialization\nreached_end <- FALSE\ncon_map <- contour_map\nloop_count <- 1\nd <- 0\nqueue <- list(c(start[1], start[2], d))\n\nwhile (reached_end == FALSE & loop_count < 3000) {\n\n  #points to N, E, S, W\n  cur_loc <- queue[[1]]\n  temp <- list(c(cur_loc[1]-1, cur_loc[2], cur_loc[3]+1), \n               c(cur_loc[1], cur_loc[2]+1, cur_loc[3]+1),\n               c(cur_loc[1]+1, cur_loc[2], cur_loc[3]+1),\n               c(cur_loc[1], cur_loc[2]-1, cur_loc[3]+1))\n  \n  #check points in each direction from current location  \n  for (location in temp) {\n    queue <- add_to_queue(con_map, cur_loc, location, queue)\n  }\n  \n  #remove current location from queue\n  queue <- queue[-1]\n  #set location at * meaning already visited\n  con_map[cur_loc[1], cur_loc[2]] <- \"*\"\n  \n  #check if end location is in queue and, if so, set reached_end to TRUE\n  for (i in 1:length(queue)){\n    if (sum(queue[[i]][1:2] == c(end[1], end[2])) == 2) {\n      reached_end <- TRUE\n      d <- queue[[i]][3]\n    }\n  }\n  loop_count <- loop_count + 1\n}\n```\n:::\n\n\nThe distance is saved to ```d```.\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste(\"The number of steps to the end location is:\", d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The number of steps to the end location is: 370\"\n```\n:::\n:::\n\n\n## Part Two: Best path starting from any \"a\" location\n\nThe next part asks which path has the least number of steps from to the end goal but, this time, starting from any \"a\" location on the height-map. One could consider checking the number of steps from every \"a\" location in the map and then find the minimum however this is not the optimal approach.  Instead, you can reverse the search starting at the end location and finding the minimum steps to **any** \"a\".\n\nThe ```add_to_queue``` function is modified to now that we are descending rather than ascending which only requires changing one line.  This modified function is named ```add_to_queue2``` however it should be noted that this approach would also work for Part One.\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_to_queue2 <- function(con_map, cur_loc, new_loc, queue) {\n  if (new_loc[1] < 1 | new_loc[1] > num_rows) {\n    #do nothing if off the map\n  } else if (new_loc[2] < 1 | new_loc[2] > num_cols) {\n    #do nothing if off the map\n  } else if (con_map[new_loc[1], new_loc[2]] == \"*\") {\n    #do nothing if already visited\n  } else if (match(con_map[new_loc[1], new_loc[2]], letters) - match(con_map[cur_loc[1], cur_loc[2]], letters) < -1) {\n    #do nothing if inaccessible - logic was changed as we are now backtracking\n  } else {\n    #add to queue\n    if (list(new_loc) %in% queue == FALSE){\n      queue <- c(queue, list(new_loc))\n    }\n  }\n  return(queue)\n}\n```\n:::\n\n\nThe code for finding the best path is very similar as for Part One.  There are two main changes: 1) the starting point is changed to the end location and 2) the check to see whether the goal is reached is performed by checking if the location in the queue is an \"a\".\n\n::: {.cell hash='2023-07-28_aoc_Day12_BreadthFirst_cache/html/unnamed-chunk-9_9647a1ac9576b729c55501508b92030a'}\n\n```{.r .cell-code}\n#initialization\nreached_end <- FALSE\ncon_map <- contour_map\nloop_count <- 1\nd <- 0\n\n#need to start at \"E\" - the desired end point\nqueue <- list(c(end[1], end[2], d))\n\nwhile (reached_end == FALSE & loop_count < 3000) {\n\n  #points to N, E, S, W\n  cur_loc <- queue[[1]]\n  temp <- list(c(cur_loc[1]-1, cur_loc[2], cur_loc[3]+1), \n               c(cur_loc[1], cur_loc[2]+1, cur_loc[3]+1),\n               c(cur_loc[1]+1, cur_loc[2], cur_loc[3]+1),\n               c(cur_loc[1], cur_loc[2]-1, cur_loc[3]+1))\n    \n  for (location in temp) {\n    #now using the backtracking function\n    queue <- add_to_queue2(con_map, cur_loc, location, queue)\n  }\n  \n  #remove current location from queue\n  queue <- queue[-1]\n  #set location at * meaning already visited\n  con_map[cur_loc[1], cur_loc[2]] <- \"*\"\n\n  #check if queue location is \"a\" and, if so, set reached_end to TRUE\n  for (i in 1:length(queue)){\n    if (con_map[queue[[i]][1], queue[[i]][2]] == \"a\") {\n      reached_end <- TRUE\n      d <- queue[[i]][3]\n    }\n  }\n  loop_count <- loop_count + 1\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste(\"The minimum number of steps from any 'a' location to the end location is:\", d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The minimum number of steps from any 'a' location to the end location is: 363\"\n```\n:::\n:::\n\n\n## Bonus: what actually is the path?\n\nAfter solving the Day 12 problem, I had this burning question of how would you actually find the best path using this approach.  The solution to the problem so far had only required knowing the number of steps to get to the end goal and not the route to take.  In order to answer this additional question, the steps to reach the end location needs to be saved for each active path end.  This requires a change to the queue where we now save each path as a list within a list.  The ```add_to_queue``` function needs to be modified again related to checking if the new series of steps in already in the queue.  As written, another check is needed to see if the current location has been already visited.\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_to_queue3 <- function(con_map, cur_loc, new_loc, queue) {\n  if (new_loc[1] < 1 | new_loc[1] > num_rows) {\n    #do nothing if off the map\n  } else if (new_loc[2] < 1 | new_loc[2] > num_cols) {\n    #do nothing if off the map\n  } else if (con_map[new_loc[1], new_loc[2]] == \"*\") {\n    #do nothing if already visited\n  } else if (con_map[cur_loc[1], cur_loc[2]] == \"*\") {\n    #do nothing if already visited\n  } else if (match(con_map[new_loc[1], new_loc[2]], letters) - match(con_map[cur_loc[1], cur_loc[2]], letters) > 1) {\n    #do nothing if inaccessible\n  } else {\n    #add path to end of queue if not already existing\n    if (sum(c(queue[[1]], list(new_loc)) %in% queue) == 0){\n      queue <- c(queue, list(c(queue[[1]], list(new_loc))))\n      #print(queue)\n    }\n  }\n  return(queue)\n}\n```\n:::\n\n\nThe best path for Part One is now determined taking into account the new list within a list structure.\n\n::: {.cell hash='2023-07-28_aoc_Day12_BreadthFirst_cache/html/unnamed-chunk-12_35ea9cd279cdfc843e10a58309fade23'}\n\n```{.r .cell-code}\nreached_end <- FALSE\ncon_map <- contour_map\nloop_count <- 1\nd <- 0\nwhereinq <- 0\n#now the path are nested\nqueue <- list(list(c(start[1], start[2], d)))\n\nwhile (reached_end == FALSE & loop_count < 30000) {\n\n  #points to N, E, S, W\n  cur_loc <- queue[[1]][[length(queue[[1]])]] #new nested scheme - take last location in path\n  temp <- list(c(cur_loc[1]-1, cur_loc[2], cur_loc[3]+1), \n               c(cur_loc[1], cur_loc[2]+1, cur_loc[3]+1),\n               c(cur_loc[1]+1, cur_loc[2], cur_loc[3]+1),\n               c(cur_loc[1], cur_loc[2]-1, cur_loc[3]+1))\n    \n  for (location in temp) {\n    #print(location)\n    queue <- add_to_queue3(con_map, cur_loc, location, queue)\n  }\n  \n  queue <- queue[-1]\n  con_map[cur_loc[1], cur_loc[2]] <- \"*\"\n  \n  # if (list(c(end_row, end_col)) %in% queue) {\n  #   reached_end <- TRUE\n  # }\n  \n  for (i in 1:length(queue)){\n    if (sum(queue[[i]][[length(queue[[i]])]][1:2] == c(end[1], end[2])) == 2) {\n      reached_end <- TRUE\n      d <- queue[[i]][[length(queue[[i]])]][3]\n      whereinq <- i\n    }\n  }\n  loop_count <- loop_count + 1\n}\n```\n:::\n\n\nLet's plot the best path using the original height-map layout.  We will accomplish this plot by converting the list containing the best path into a table and the matrix containing the height-map into a long-form table.\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load tidyverse libraries\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n#Long-form table for the height-map\ncontour_data <- contour_map |>\n  as_tibble() |>\n  mutate(row_id = row_number()) |>\n  pivot_longer(cols = starts_with(\"V\"), names_to = \"name\", values_to = \"value\") |>\n  mutate(col_id = as.integer(sub(\"V\", \"\", name)))|>\n  select(row_id, col_id, value)\n\nhead(contour_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  row_id col_id value\n   <int>  <int> <chr>\n1      1      1 a    \n2      1      2 b    \n3      1      3 a    \n4      1      4 a    \n5      1      5 c    \n6      1      6 c    \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbest_path <- as_tibble(queue[[length(queue)]], .name_repair = \"minimal\")\nbest_path <- as_tibble(t(best_path), .name_repair = \"minimal\")\nnames(best_path) <- c(\"row_id\", \"col_id\", \"d\")\n\nhead(best_path)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  row_id col_id     d\n   <dbl>  <dbl> <dbl>\n1     21      1     0\n2     20      1     1\n3     19      1     2\n4     18      1     3\n5     17      1     4\n6     16      1     5\n```\n:::\n:::\n\nNow, a left-join is used to merge the best path with the original height-map for plotting purposes.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data <- left_join(contour_data, best_path, by = c(\"row_id\", \"col_id\"))\n```\n:::\n\n\nFinally, we visualize the path taken.\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- plot_data |>\n  rowwise() |>\n  mutate(onpath = ifelse(is.na(d), \"no\", \"yes\")) |>\n  ungroup() |>\n  ggplot(aes(x = col_id, y = row_id, label = value, color = factor(onpath))) +\n    geom_text() +\n    scale_y_reverse() +\n    labs(color = \"On the path?\") +\n    theme_void()\np1\n```\n\n::: {.cell-output-display}\n![](2023-07-28_aoc_Day12_BreadthFirst_files/figure-html/unnamed-chunk-16-1.png){width=864}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n## Summary\n\nThe day 12 problem was solved by implementing a breadth-first search algorithm in R.  The key to solving Part Two was to realize the path could be solved backwards from the end goal to identify the first time an \"a\" was found.  It would have taken a great deal more computing power to find the path from **every** \"a\" in the input dataset as there were many.  As a bonus, Part One was implemented in a manner so that the actual path could be saved and plotted.  There are some inefficiencies in the code but it did the job and found the correct solutions.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-08-01\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.353 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P dplyr       * 1.1.2   2023-04-20 [?] CRAN (R 4.2.3)\n P ggplot2     * 3.4.2   2023-04-03 [?] CRAN (R 4.2.3)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n P tidyr       * 1.3.0   2023-01-24 [?] CRAN (R 4.2.3)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpQbQ1zv/renv-use-libpath-1dd84e02a8e\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/R-4.2/x86_64-w64-mingw32/30182023\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}