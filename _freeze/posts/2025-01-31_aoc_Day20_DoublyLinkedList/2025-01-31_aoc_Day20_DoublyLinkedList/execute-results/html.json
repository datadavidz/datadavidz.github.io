{
  "hash": "61e5dbb67c6b52f11e5ddbc958abef9e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code Day 20: Doubly-Linked List\"\ndate: 2025-01-31\n---\n\n::: {.cell}\n\n:::\n\n\n\nTrack an encryption algorithm by implementing a doubly-linked list\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 20.  The goal is to find coordinates to a grove by applying an encryption algorithm to a sequence of numbers.  The coordinates are then found on the 1000th, 2000th and 3000th number away from the 0 value in the number sequence.  The encryption algorithm is to move each number in the sequence forward or backward in the list according to its value.  A negative value moves the number backwards and a positive value moves the number forwards.  Each number in the sequence is moved in the order of the original sequence.  The list is circular meaning moving past the last number in the sequence results in starting back at the beginning of the sequence and vice versa.  An example is provided as such:\n\n```\nInitial arrangement:\n1, 2, -3, 3, -2, 0, 4\n\n1 moves between 2 and -3:\n2, 1, -3, 3, -2, 0, 4\n\n2 moves between -3 and 3:\n1, -3, 2, 3, -2, 0, 4\n\n-3 moves between -2 and 0:\n1, 2, 3, -2, -3, 0, 4\n\n3 moves between 0 and 4:\n1, 2, -2, -3, 0, 3, 4\n\n-2 moves between 4 and 1:\n1, 2, -3, 0, 3, 4, -2\n\n0 does not move:\n1, 2, -3, 0, 3, 4, -2\n\n4 moves between -3 and 0:\n1, 2, -3, 4, 0, 3, -2\n```\n\nAfter each number in the initial sequence has been mixed one time, the coordinates are found by cycling through the list starting at the 0 value.  The puzzle solution is then found from the summation of the 3 coordinates corresponding to the 1000th, 2000th and 3000th number away from 0 in the mixed sequence.\n\n## Loading the input file\n\nEach number in the sequence is captured in a single line of the input file.  The ```read_lines``` function from the ```readr``` package is used to read the input file.  The input file sequence contained 5000 numbers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\nfilepath <- here::here(\"./posts/data/aoc/day20_input.txt\")\n#filepath <- here::here(\"./posts/data/aoc/day20_test.txt\")\n\nfileseq <- read_lines(filepath, skip_empty_rows = TRUE) |> as.numeric()\n```\n:::\n\n\n\n## Data Cleaning / Structure\n\nA doubly-linked list structure is used to keep track of the mixed sequence.  In this case, the number before and after each sequence element is recorded and updated at each step.  This structure is programmatically easier to maintain rather than slicing and reforming the list each time.  The initial structure is set up from the input file using the ```create_linked_list``` function shown below.  Each list element contains the value (v), left or preceding element (l) and right or succeeding element (r).  The modulo calculation is used to connect the beginning and end of the list to make it circular.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_linked_list <- function(file_seq, crypt_key) {\n  lnk_lst <- list()\n  for (i in 1:length(file_seq)) {\n    node <- list(v = file_seq[i] * crypt_key, \n                l = ifelse(((i - 1) %% length(file_seq)) == 0, as.numeric(length(file_seq)), ((i - 1) %% length(file_seq))),\n                r = ifelse(((i + 1) %% length(file_seq)) == 0, length(file_seq), ((i + 1) %% length(file_seq))))\n    lnk_lst <- c(lnk_lst, list(node))\n  }\n  return(lnk_lst)\n}\n```\n:::\n\n\n\n## Mixing the Sequence\n\nAs mentioned previously, each element is moved forwards or backwards in the sequence according to its value.  This mixing is performed in two steps: removing the element (node) from its current position and inserting the element (node) in its new position.  In each case, the links for the adjacent elements also need to be updated.  The function for the first step takes the current sequence and the location of the element to be moved.  If the element doesn't move as its value is 0 or the movement would result in the same position, no update is performed and the sequence is returned without change.  Otherwise, the links for the adjacent elements are changed to point to each other.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove_node <- function(lnk_lst, lst_loc) {\n  value <- lnk_lst[[lst_loc]]$v\n  movement <- ifelse(value >= 0, value %% (length(lnk_lst)-1), -value %% (length(lnk_lst)-1))\n  if (value == 0 | movement == 0){  \n  #if (value == 0){\n    return(lnk_lst)\n  }\n  l_loc <- lnk_lst[[lst_loc]]$l\n  r_loc <- lnk_lst[[lst_loc]]$r\n  lnk_lst[[l_loc]]$r <- r_loc\n  lnk_lst[[r_loc]]$l <- l_loc\n  return(lnk_lst)\n}\n```\n:::\n\n\n\nThe function for the second step of inserting the element (node) in its new location is shown below.  Again, if the element value is 0 or the movement results in the same position, the sequence is returned unchanged.  The cases for moving forwards or backwards in the sequence are handled separately as it is more clear programmatically. In both cases, the links for the inserted element and the adjacent elements are updated.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninsert_node <- function(lnk_lst, lst_loc) {\n  value <- lnk_lst[[lst_loc]]$v\n  movement <- ifelse(value >= 0, value %% (length(lnk_lst)-1), -value %% (length(lnk_lst)-1))\n  if (value == 0 | movement == 0){\n    return(lnk_lst)\n  }\n  #move right\n  if (value > 0) {\n    new_loc <- lst_loc\n    for (i in 1:movement) {\n    #for (i in 1:(value %% length(lnk_lst))) {\n      new_loc <- lnk_lst[[new_loc]]$r\n      #print(new_loc)\n    }\n    #update inserted node left\n    lnk_lst[[lst_loc]]$l <- new_loc\n    #update inserted node right\n    lnk_lst[[lst_loc]]$r <- lnk_lst[[new_loc]]$r\n    #update right to insert to new left\n    lnk_lst[[lnk_lst[[new_loc]]$r]]$l <- lst_loc\n    #update left to insert to new right\n    lnk_lst[[new_loc]]$r <- lst_loc\n\n  # move left\n  } else {\n    new_loc <- lst_loc\n    for (i in 1:movement) {    \n    #for (i in 1:(-value %% length(lnk_lst))) {\n      new_loc <- lnk_lst[[new_loc]]$l\n    }\n    #update inserted node right\n    lnk_lst[[lst_loc]]$r <- new_loc\n    #update inserted node left\n    lnk_lst[[lst_loc]]$l <- lnk_lst[[new_loc]]$l\n    #update left to insert to new right\n    lnk_lst[[lnk_lst[[new_loc]]$l]]$r <- lst_loc    \n    #update right to insert to new left\n    lnk_lst[[new_loc]]$l <- lst_loc\n\n  }\n  return(lnk_lst)\n}\n```\n:::\n\n\n\nA simple function is created to return the position of the element with the zero value in the sequence.  This function is needed for the calculation of the grove coordinates.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_zero <- function(lnk_lst) {\n  for (i in 1:length(lnk_lst)) {\n    if (lnk_lst[[i]]$v == 0) return(i)\n  }\n  return(0)\n}\n```\n:::\n\n\n\n## Part 1 Solution\n\nThe linked list is first created from the input sequence and then the sequence is mixed according to the encryption algorithm.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinked_list <- create_linked_list(fileseq, 1)\n\nfor (i in 1:length(linked_list)) {\n  linked_list <- remove_node(linked_list, i)\n  linked_list <- insert_node(linked_list, i)\n}\n```\n:::\n\n\n\nThe solution is then found by summing the values for the 1000th, 2000th and 3000th elements from the element containing the zero value.  For this puzzle input, the total of the grove coordinates was 13883. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#puzzle solution initialized at 0\ntotal <- 0\n#start from zero\nnew_loc <- find_zero(linked_list)\n\nfor (i in 1:3){\n  for (i in 1:1000) {\n    new_loc <- linked_list[[new_loc]]$r\n  }\ntotal <- total + linked_list[[new_loc]]$v\n}\n\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13883\n```\n\n\n:::\n:::\n\n\n## Part 2 Solution\n\nIn part 2, a decryption key, 811589153, is included which is multiplied by each number in the initial sequence.  Also, the sequence is now mixed ten times rather than just once.  With these two minor adjustments, the same functions can be used as in Part 1.  Increasing the values does not increase the computation time much with the use of the modulo transformation.  Of course, the mixing takes longer since the sequence is mixed 10 times now.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinked_list2 <- create_linked_list(fileseq, 811589153)\n\nfor (j in 1:10) {\n  for (i in 1:length(linked_list2)) {\n    linked_list2 <- remove_node(linked_list2, i)\n    linked_list2 <- insert_node(linked_list2, i)\n  }\n}\n```\n:::\n\n\n\nThe grove coordinates are found as in Part 1 and the summation is 19185967576920.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal <- 0\nnew_loc <- find_zero(linked_list2)\n\nfor (i in 1:3){\n  for (i in 1:1000) {\n    new_loc <- linked_list2[[new_loc]]$r\n  }\ntotal <- total + linked_list2[[new_loc]]$v\n}\n\noptions(scipen = 999)\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19185967576920\n```\n\n\n:::\n:::\n\n\n## Summary\nAn encryption algorithm was tracked using a doubly-linked list.  This list structure enabled a programmatically clear approach to solving the puzzle.  The use of the modulo operator helped with the overall computation time and hardly any change was required to move from Part 1 with modest values to Part 2 with significantly higher values.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.2 (2024-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2025-01-31\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.5.57 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P readr       * 2.1.5   2024-01-10 [?] CRAN (R 4.4.2)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.4.2)\n\n [1] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/windows/R-4.4/x86_64-w64-mingw32\n [2] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/windows/R-4.4/x86_64-w64-mingw32/6698a5f3\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}