{
  "hash": "7b84bd2e5bc880a1a4cb607dfe186f5a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code Day 21: Named List\"\ndate: 2025-02-04\nexecute: \n  cache: true\n---\n\n::: {.cell}\n\n:::\n\n\n\nFind solution by looping through a series of equations stored in a named list\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 21.  Monkeys are yelling either a specific number or the result of a math operation.  The input file consists of the monkey's name and a colon followed by their yell as shown below.\n\n```\nroot: pppw + sjmn\ndbpl: 5\ncczh: sllz + lgvd\nzczc: 2\nptdq: humn - dvpt\ndvpt: 3\nlfqf: 4\nhumn: 5\nljgn: 2\nsjmn: drzm * dbpl\nsllz: 4\npppw: cczh / lfqf\nlgvd: ljgn * ptdq\ndrzm: hmdt - zczc\nhmdt: 32\n```\n\nIn this case, the monkey named \"dbpl\" will yell a specific number, 5.  The monkey named \"cczh\" will yell the summation of the number yelled by the monkeys named \"sllZ\" and \"lgvd\".  The monkeys don't yell until they have a number or all the numbers hav been called which are required for their math operation.  Your goal is to figure out what the monkey named \"root\" will yell before he yells it.\n\n## Loading the input file\n\nEach monkey is captured in a single line of the input file and the actual file contains over 2000 monkeys.  The ```read_lines``` function from the ```readr``` package is used to read the input file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\noptions(scipen = 999)\n\nfilepath <- here::here(\"./posts/data/aoc/day21_input.txt\")\n#filepath <- here::here(\"./posts/data/aoc/day21_test.txt\")\n\nyells <- read_lines(filepath, skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1 Solution\n\nA while loop is used to cycle through the yelling monkeys.  The monkeys with specific numbers are stored in a named list called ```monkeys``` and removed from the iterated list of monkeys yet to yell (\"x\").  If the result of the math operation is available, the monkey is added to the ```monkeys``` list otherwise it is added to the end of the list of monkeys yet to yell.  The loop continues until the monkey named \"root\" yells.  The math operation is performed by parsing the text of the math operation and performing the calculation using the ```eval``` function.  A couple of functions from the ```stringr``` package are used to manipulate and evaluate the strings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonkeys <- list()\nx <- yells\n\nwhile(length(x) > 0) {\n a <- x[1]\n x <- tail(x, -1)\n response <- str_split(a, \": \")\n name <- response[[1]][1]\n expr <- response[[1]][2]\n if (str_detect(expr, \"^[[:digit:]]+$\")) {\n   monkeys[name] <- as.numeric(expr)\n } else {\n   expression <- str_split(expr, \" \")\n   left <- expression[[1]][1]\n   op <- expression[[1]][2]\n   right <- expression[[1]][3]\n   #test is both numbers for math operation are available\n   test_left <- left %in% names(monkeys)\n   test_right <- right %in% names(monkeys)\n   if (test_left & test_right) {\n     left_val <- monkeys[[left]]\n     right_val <- monkeys[[right]]\n     result <- eval(parse(text = paste0(left_val, op, right_val)))\n     monkeys[name] <- result\n     if (name == \"root\") break\n   } else {\n     #add unsolved math operation to end of the list\n     x <- c(x, a)\n   }\n }\n}\n\nmonkeys[[\"root\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 364367103397416\n```\n\n\n:::\n:::\n\n\nThe loop performed above using the named list runs quite quickly which will be important for Part 2.  Also, notice that the number yelled by \"root\" is quite large: 364367103397416.\n\n## Part 2 Solution\n\nSeveral changes to the puzzle are introduced in Part 2.  First, the monkey named \"humn\" is not a monkey after all and it actually stands for human and that human is you.  Also, the math operation for the monkey named root is not an addition but rather an equal sign meaning the numbers must match.  For the example above, the monkey \"pppw\" and the monkey \"sjmn\" must yell the same number.  So, you need to figure out the number to yell as \"humn\" in order for the numbers yelled by the two monkeys associated with root are the same.\n\nI saw online a couple of Python-based solution which used ```sympy``` to solve for the correct number for \"humn\".  I couldn't find a similar R-based solver in my initial search and so I tried an iterative search.  As the Part 1 solution was quite large, I also realized that the number for \"humn\" could be quite large as well.  I also assumed the solution would be an integer.\n\nThe first function, ```find_root``` was created to find the names of the two monkeys required for \"root\" to yell.  I created this function because those monkeys were different between the test data and the input file.  This function enables me to switch between those two datasets without manually resetting the associated strings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_root <- function(yells_vec) {\n  for (a in yells_vec) {\n   response <- str_split(a, \": \")\n   name <- response[[1]][1]\n   expr <- response[[1]][2]\n   if (name == \"root\") {\n     expression <- str_split(expr, \" \")\n     left <- expression[[1]][1]\n     right <- expression[[1]][3]\n     #if found, return in a string vector\n     return(c(left, right))\n   }\n  }\n  #if can't find root, return zeros\n  return(c(0,0))\n}\n```\n:::\n\n\n\nNext, the loop created in Part 1 is converted into a function with some small changes.  The number for \"humn\" is replaced with a guess which is an argument to the function.  The two monkeys associated with \"root\" are passed as the ```root_lbls``` argument and determined from the ```find_root``` function.  If the monkey name is \"root\", the difference is calculated between the monkeys as ```diff``` when both of those monkeys have yelled their numbers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhumn_search <- function(yells_vec, guess, root_lbls) {\n  monkeys <- list()\n  x <- yells_vec\n  \n  while(length(x) > 0) {\n   a <- x[1]\n   x <- tail(x, -1)\n   response <- str_split(a, \": \")\n   name <- response[[1]][1]\n   expr <- response[[1]][2]\n   if (str_detect(expr, \"^[[:digit:]]+$\")) {\n     #replace humn with the guess instead of what was in the file\n     monkeys[name] <- ifelse(name == \"humn\", guess, as.numeric(expr))\n   } else {\n     expression <- str_split(expr, \" \")\n     left <- expression[[1]][1]\n     op <- expression[[1]][2]\n     right <- expression[[1]][3]\n     test_left <- left %in% names(monkeys)\n     test_right <- right %in% names(monkeys)\n     if (test_left & test_right) {\n       left_val <- monkeys[[left]]\n       right_val <- monkeys[[right]]\n       result <- eval(parse(text = paste0(left_val, op, right_val)))\n       monkeys[name] <- result\n       if (name == \"root\") {\n         #calculate difference between the monkeys related to root\n         diff <- monkeys[[root_lbls[1]]] - monkeys[[root_lbls[2]]]\n         break\n       }\n     } else {\n       x <- c(x, a)\n     }\n   }\n  }\n  return(diff)\n}\n```\n:::\n\n\n\nThe first step to find the solution to Part 2 was to identify the number of digits.  I did this by iterating by powers of 10 from 1 up to 20 and stopping once a sign change in the difference from ```humn_search``` is detected.  For the input dataset, the solution was determined to be a 13-digit number.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nval_srch <- 1:20\nroot_labels <- find_root(yells)\ncurr_sign <- sign(humn_search(yells, 1, root_labels))\n\nfor (i in val_srch) {\n  new_sign <- sign(humn_search(yells, 1*10^i, root_labels))\n  if (new_sign != curr_sign) break\n}\n```\n:::\n\n\n\nThe next step was to determine each digit for the solution.  Two for loops were used to cycle through all 13 digits starting at the highest place and, again, checking for the sign change.  The ```sign``` function will return -1 for a negative number, 1 for a positive number and 0 for zero.  If the difference is 0, the solution has been found and the number is returned.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nval2_srch <- 1:10\nsolution <- 0\n\nfor (k in 1:i) {\n  for (j in val2_srch) {\n    new_sign <- sign(humn_search(yells, solution + j*10^(i-k), root_labels))\n    if (new_sign != curr_sign) break\n  }\n  #if sign == 0 then the solution has been found\n  if (new_sign == 0) {\n    solution <- solution + j*10^(i-k)\n  } else {\n    solution <- solution + (j-1)*10^(i-k)\n  }\n  if (new_sign == 0) break\n}\n\nsolution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3782852515583\n```\n\n\n:::\n:::\n\n\nThe number to be yelled by me, the \"humn\", was found to be 3782852515583.  This was a bit of a hacky way to arrive at the solution and made certain assumptions that the solution would be positive, an integer and would have one sign change transition across this range.\n\n## Summary\nA while loop with a named list structure was used to efficiently arrive at the solution to Part 1.  A very similar loop was implemented as a function to search for the number to solve Part 2.  Further optimizations are certainly possible however this less optimum solution was able to arrive at the solution in under a minute.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.2 (2024-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2025-02-04\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.5.57 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P readr       * 2.1.5   2024-01-10 [?] CRAN (R 4.4.2)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.4.2)\n P stringr     * 1.5.1   2023-11-14 [?] CRAN (R 4.4.2)\n\n [1] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/windows/R-4.4/x86_64-w64-mingw32\n [2] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/windows/R-4.4/x86_64-w64-mingw32/6698a5f3\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}