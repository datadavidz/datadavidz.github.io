{
  "hash": "67c4774de227a2d709d784bb4070b989",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 10: Hidden Message\"\ndate: 2023-07-18\n---\n\n::: {.cell}\n\n:::\n\n\nFollowing a series of instructions to display a hidden series of letters\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 10.  The communication device fell into the river and got damaged.  The device consists of a CPU which processes a series of instructions according to a fixed cycle rate.  The instructions are used to set a single register \"X\".  A CRT display is controlled by the CPU to light certain pixels depending upon the current cycle and the register X.\n\n## Loading the input file\n\nThe input file contains instructions for the CPU to set the register X.  There are only two types of instructions, noop and addx.  The \"noop\" instruction takes one cycle to execute and has no other effect.  The \"addx V\" instruction takes two cycle to execute and adds the value \"V\" to register X at the end of the second cycle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nlibrary(purrr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'purrr' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nfilepath <- here::here(\"./posts/data/aoc/day10_input.txt\")\ncommands <- readLines(filepath)\n\nhead(commands)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"noop\"   \"noop\"   \"noop\"   \"addx 5\" \"noop\"   \"addx 1\"\n```\n:::\n:::\n\n## Part One: CPU Instructions\n\nThe instructions from the input file are executed as described above.  A key point is that the update to the X register value does not occur until after the end of the cycle.  The question for Part One is to find the signal strength **during** each cycle and record the signal strength for the 20th cycle and every 40 cycles after that (i.e. 60th, 100th, 140th, 180th and 220th cycles). Signal strength is calculated by multiplying the current cycle by the X register.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#X Register\nreg_X <- 1\n#Cycle\ni <- 1\n#Signal Strength\nsig_str <- list()\n\nfor (command in commands) {\n  move <- unlist(str_split(command, \" \"))\n  if (move[1] == \"noop\") {\n    #sig_str <- c(sig_str, list(c(command, i, reg_X, i * reg_X)))\n    sig_str <- c(sig_str, list(i * reg_X))\n    i <- i + 1\n\n  } else if (move[1] == \"addx\") {\n    #sig_str <- c(sig_str, list(c(command, i, reg_X, i * reg_X)))\n    sig_str <- c(sig_str, list(i * reg_X))    \n    i <- i + 1\n\n    \n    #sig_str <- c(sig_str, list(c(command, i, reg_X, i * reg_X)))\n    sig_str <- c(sig_str, list(i * reg_X))\n    reg_X <- reg_X + as.numeric(move[2])\n    i <- i + 1\n\n  } else {}\n}\n```\n:::\n\n\nThe ```walk``` function from the ```purrr``` package can be used to print the signal strength for each of the cycles of interest.\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle <- c(20, 60, 100, 140, 180, 220)\n\ncycle |> walk(function(cycle) print(paste(\"Signal Strength for Cycle\", cycle, \"is\", sig_str[[cycle]])))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Signal Strength for Cycle 20 is 440\"\n[1] \"Signal Strength for Cycle 60 is 1260\"\n[1] \"Signal Strength for Cycle 100 is 1600\"\n[1] \"Signal Strength for Cycle 140 is 2940\"\n[1] \"Signal Strength for Cycle 180 is 3780\"\n[1] \"Signal Strength for Cycle 220 is 3740\"\n```\n:::\n:::\n\nThe answer to Part One is to add the signal strengths for the cycles of interest.\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(unlist(sig_str[cycle]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13760\n```\n:::\n:::\n\n## Part Two: CRT Display\n\nIt has become evident that the X Register controls the position of a sprite on a CRT screen.  The sprite is 3 pixels wide and the X register sets the middle position of the sprite.  The CRT screen is 40 pixels wide and has 6 rows.  The left most pixel in each row is in position 0 and the right most pixel is at position 39.  A pixel is lit with each clock cycle of the CPU.  The pixel is light (#) if the sprite overlaps with the current clock cycle and dark (.) if the sprite does not overlap.\n\nThe logic to determine whether the sprite is overlapping with the current cycle requires two operations: 1) subtract 1 from the current cycle since cycle 1 would correspond with sprite position 0 and 2) perform modulo 40 operation since each row of the CRT contains the same positioning relative to the sprite.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg_X <- 1\ni <- 1\nsprite <- (reg_X-1):(reg_X+1)\nsig_str <- list()\ncrt <- character()\n\nfor (command in commands) {\n  move <- unlist(str_split(command, \" \"))\n  if (move[1] == \"noop\") {\n    #sig_str <- c(sig_str, list(c(command, i, reg_X, i * reg_X)))\n    crt <- c(crt, ifelse(((i-1) %% 40) %in% sprite, \"#\", \".\"))\n    sig_str <- c(sig_str, list(i * reg_X))\n    i <- i + 1\n\n  } else if (move[1] == \"addx\") {\n    #sig_str <- c(sig_str, list(c(command, i, reg_X, i * reg_X)))\n    crt <- c(crt, ifelse(((i-1) %% 40) %in% sprite, \"#\", \".\"))\n    sig_str <- c(sig_str, list(i * reg_X))    \n    i <- i + 1\n\n    #sig_str <- c(sig_str, list(c(command, i, reg_X, i * reg_X)))\n    crt <- c(crt, ifelse(((i-1) %% 40) %in% sprite, \"#\", \".\"))\n    sig_str <- c(sig_str, list(i * reg_X))\n    reg_X <- reg_X + as.numeric(move[2])\n    sprite <- (reg_X-1):(reg_X+1)\n    i <- i + 1\n\n  } else {}\n}\n```\n:::\n\n\nThe CRT can then be viewed by converting the character array to a matrix with the size dimensions of the screen.  A simple print command without the quotes allows for the letters to be displayed.\n\n::: {.cell}\n\n```{.r .cell-code}\nview_crt <- matrix(crt, nrow = 6, ncol = 40, byrow = TRUE)\nprint(view_crt, quote = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n[1,] #    #    #    .    .    #    #    #    #    .     #     .     .     #    \n[2,] #    .    .    #    .    #    .    .    .    .     #     .     #     .    \n[3,] #    .    .    #    .    #    #    #    .    .     #     #     .     .    \n[4,] #    #    #    .    .    #    .    .    .    .     #     .     #     .    \n[5,] #    .    #    .    .    #    .    .    .    .     #     .     #     .    \n[6,] #    .    .    #    .    #    .    .    .    .     #     .     .     #    \n     [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]\n[1,] .     #     #     #     #     .     .     #     #     .     .     #    \n[2,] .     .     .     .     #     .     #     .     .     #     .     #    \n[3,] .     .     .     #     .     .     #     .     .     .     .     #    \n[4,] .     .     #     .     .     .     #     .     .     .     .     #    \n[5,] .     #     .     .     .     .     #     .     .     #     .     #    \n[6,] .     #     #     #     #     .     .     #     #     .     .     #    \n     [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38]\n[1,] #     #     .     .     #     #     #     #     .     #     #     #    \n[2,] .     .     #     .     #     .     .     .     .     #     .     .    \n[3,] .     .     #     .     #     #     #     .     .     #     #     #    \n[4,] #     #     .     .     #     .     .     .     .     #     .     .    \n[5,] .     .     .     .     #     .     .     .     .     #     .     .    \n[6,] .     .     .     .     #     #     #     #     .     #     .     .    \n     [,39] [,40]\n[1,] #     .    \n[2,] .     .    \n[3,] .     .    \n[4,] .     .    \n[5,] .     .    \n[6,] .     .    \n```\n:::\n:::\n\nThe eight, hidden letters are revealed to be: \"R F K Z C P E F\".\n\n## Summary\nThe trickiest part of this day's problem was figuring out whether the X register was updated **during** the cycle or after the cycle.  Using the test data and solution, I was able to determine that it was not updated during the cycle.  The other part that was a bit annoying was the CRT where the first pixel was at position 0.  Must have been a Python user who wrote this problem.  Once the problem was understood, the solution was straightforward to implement in R.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-07-21\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.353 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P purrr       * 1.0.1   2023-01-10 [?] CRAN (R 4.2.3)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpIBYgSQ/renv-use-libpath-10c43791652\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/R-4.2/x86_64-w64-mingw32/30182023\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}