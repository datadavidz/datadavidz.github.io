{
  "hash": "bbafe59d6643065c19ec1fdb726c2e43",
  "result": {
    "markdown": "---\ntitle: \"Prediction of Concrete Strength using XGBoost\"\ndate: \"2022-09-24\"\n---\n\n\nA gradient boosting model to predict the compressive strength of concrete was built using a tidymodels approach.\n\nIn this post, we will begin to use machine learning techniques for predicting compressive strength of formulations using the concrete dataset.  In a previous post, we created a model using a conventional material modeling approach which resulted in an R^2^ of 0.78.  Here we will use an XGBoost model to predict compressive strength and compare the results with a conventional material model.\n\n## Load libraries and data\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nlibrary(tidyverse)\n\n#Tidymodels\nlibrary(tidymodels)\nlibrary(vip)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilename <- \"Concrete_Data.xls\"\n\nfolder <- \"../data/\"\nnumberCols <- 9 #total number of columns in spreadsheet\n\ncolTypes <- rep(\"numeric\", numberCols)\nconcrete_tbl <- read_excel(path = paste0(folder, filename), col_types = colTypes)\n\nconcrete_tbl <- concrete_tbl %>%\n  rename(cement = starts_with(\"Cement\")) %>%\n  rename(blast_furnace_slag = starts_with(\"Blast\")) %>%\n  rename(fly_ash = starts_with(\"Fly Ash\")) %>%\n  rename(water = starts_with(\"Water\")) %>%\n  rename(superplasticizer = starts_with(\"Super\")) %>%\n  rename(coarse_aggregate = starts_with(\"Coarse\")) %>%\n  rename(fine_aggregate = starts_with(\"Fine\")) %>%\n  rename(age = starts_with(\"Age\")) %>%\n  rename(compressive_strength = starts_with(\"Concrete\"))\n```\n:::\n\n\n## Stage 1: Model Tuning\n\nInitial splitting of the dataset into Training and Test Dataset  Here we use the rsample package to create an 80/20 split.  The concrete dataset contains 1030 formulations of which 825 are randomly assigned to training and 205 are randomly assigned to testing.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nconcrete_split <- initial_split(concrete_tbl, prop = 0.80)\nconcrete_train <- training(concrete_split)\nconcrete_test <- testing(concrete_split)\n```\n:::\n\n\nPreprocessing is accomplished by using the recipe package.  The recipe provides the steps required to transform our raw data into a dataset suitable for machine learning.  The Concrete dataset actually doesn't require much reformatting.  The major issue was the lengthy column names which was addressed immediately after the dataset was imported.  The dataset contained all numerical values and no missing data.  Initially we will just center and scale the predictors before sending to the nnet model.\n\n::: {.cell}\n\n```{.r .cell-code}\nconcrete_rec <- recipe(compressive_strength ~ ., data = concrete_train) %>%\n  step_center(all_predictors()) %>%\n  step_scale(all_predictors())\n\nconcrete_rec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRecipe\n\nInputs:\n\n      role #variables\n   outcome          1\n predictor          8\n\nOperations:\n\nCentering for all_predictors()\nScaling for all_predictors()\n```\n:::\n:::\n\n\nCross validation folds are created in order to assess the performance of the model parameters.  Here we use 5-fold cross validation to create splits from our training dataset and also using the preprocessing pipeline specified above.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(234)\nconcrete_folds <- vfold_cv(concrete_train, v = 5)\n\nconcrete_folds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#  5-fold cross-validation \n# A tibble: 5 × 2\n  splits            id   \n  <list>            <chr>\n1 <split [659/165]> Fold1\n2 <split [659/165]> Fold2\n3 <split [659/165]> Fold3\n4 <split [659/165]> Fold4\n5 <split [660/164]> Fold5\n```\n:::\n:::\n\n\nModel specifications are created using the parsnip package.  Here we specify a boosted tree model using the XGBoost engine.  Notice that the min n, tree depth and learn rate parameters have been specified to be tuned.  \n\n::: {.cell}\n\n```{.r .cell-code}\nxgboost_spec = boost_tree(\n  mode = \"regression\",\n  trees = 1000,\n  min_n = tune(),\n  tree_depth = tune(),\n  learn_rate = tune()\n) %>%\n  set_engine(\"xgboost\", objective = \"reg:squarederror\") %>%\n  set_mode(\"regression\")\n\nxgboost_spec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBoosted Tree Model Specification (regression)\n\nMain Arguments:\n  trees = 1000\n  min_n = tune()\n  tree_depth = tune()\n  learn_rate = tune()\n\nEngine-Specific Arguments:\n  objective = reg:squarederror\n\nComputational engine: xgboost \n```\n:::\n:::\n\n\nGrid specifications sets up a variety of parameter values used with our model to find which combination yields the lowest prediction error (or best accuracy).  Here we specify the parameter ranges and grid function using the dials package.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(345)\nxgboost_grid <- grid_max_entropy(min_n(), tree_depth(), learn_rate(), size = 30)\n\nxgboost_grid\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 × 3\n   min_n tree_depth learn_rate\n   <int>      <int>      <dbl>\n 1     6          1   8.78e- 7\n 2    38          3   9.89e- 8\n 3    30          1   1.18e- 2\n 4    23          5   3.77e- 7\n 5    37         15   1.07e-10\n 6    16          6   3.19e- 4\n 7    12          7   1.34e-10\n 8    40         10   9.93e- 8\n 9     2         15   2.08e- 8\n10    36         10   2.64e- 2\n# … with 20 more rows\n# ℹ Use `print(n = ...)` to see more rows\n```\n:::\n:::\n\n\nDefine a workflow for the tuning process\n\n::: {.cell}\n\n```{.r .cell-code}\nconcrete_wf <- workflow() %>%\n  add_recipe(concrete_rec) %>%\n  add_model(xgboost_spec)\n```\n:::\n\n\nHyperparameter tuning is now performed using the tune_grid() function from the tune package.  Here we specific the formula, model, resamples, grid and metrics.  The metrics come from the yardstick package. For regression problems, we can specify multiple metrics such as mae, mape, rmse and rsq into a metric_set().\n\n::: {.cell hash='2022-09-24_ConcreteXGB_cache/html/unnamed-chunk-18_534c3e5d1c1218e200ff7f65407da475'}\n\n```{.r .cell-code}\ndoParallel::registerDoParallel()\n\nset.seed(456)\n\nbegin <- Sys.time()\n\nxgboost_res <- tune_grid(\n  concrete_wf,\n  resamples = concrete_folds,\n  grid = xgboost_grid,\n  metrics = metric_set(rmse, rsq, mae),\n  control = control_grid(save_pred = TRUE)\n)\n\nend1 <- Sys.time() - begin\n```\n:::\n\n\n## Stage 2: Compare and Select the Best Model\n\nIdentify the best hyperparameter values using the show_best() function.\n\n::: {.cell}\n\n```{.r .cell-code}\nxgboost_res %>% show_best(\"mae\", n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 9\n  min_n tree_depth learn_rate .metric .estimator  mean     n std_err .config    \n  <int>      <int>      <dbl> <chr>   <chr>      <dbl> <int>   <dbl> <chr>      \n1    18         10    0.0265  mae     standard    2.98     5  0.103  Preprocess…\n2    28          7    0.0302  mae     standard    3.10     5  0.103  Preprocess…\n3    36         10    0.0264  mae     standard    3.14     5  0.0829 Preprocess…\n4    19          2    0.0904  mae     standard    3.37     5  0.110  Preprocess…\n5    24         14    0.00824 mae     standard    3.46     5  0.0668 Preprocess…\n```\n:::\n:::\n\n\nVisualize the tuning results  \n\n::: {.cell}\n::: {.cell-output-display}\n![](2022-09-24_ConcreteXGB_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nSelect the best parameters based on the lowest mean absolute error.\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_xgboost_best <- xgboost_res %>% select_best(\"mae\")\nparams_xgboost_best\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n  min_n tree_depth learn_rate .config              \n  <int>      <int>      <dbl> <chr>                \n1    18         10     0.0265 Preprocessor1_Model14\n```\n:::\n:::\n\n\nFinalize workflow with the best model parameters\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_xgboost <- finalize_workflow(concrete_wf, params_xgboost_best)\n\nfinal_xgboost\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: boost_tree()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n2 Recipe Steps\n\n• step_center()\n• step_scale()\n\n── Model ───────────────────────────────────────────────────────────────────────\nBoosted Tree Model Specification (regression)\n\nMain Arguments:\n  trees = 1000\n  min_n = 18\n  tree_depth = 10\n  learn_rate = 0.0264752492619167\n\nEngine-Specific Arguments:\n  objective = reg:squarederror\n\nComputational engine: xgboost \n```\n:::\n:::\n\n\nWhich Features are most important?\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_xgboost %>%\n  fit(data = concrete_train) %>%\n  extract_fit_parsnip() %>%\n  vip(aesthetics = list(fill = \"steelblue\")) +\n  labs(title = \"XGBoost Model Importance - Compressive Strength (MPa) Prediction\")\n```\n\n::: {.cell-output-display}\n![](2022-09-24_ConcreteXGB_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n### Stage 3: Train Final Model\n\nFit model on train and evaluate on test.\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_res <- last_fit(final_xgboost, concrete_split, metrics = metric_set(rmse, rsq, mae))\n```\n:::\n\n\nAssess final model performance metrics.\n\n::: {.cell}\n\n```{.r .cell-code}\ncollect_metrics(final_res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  .metric .estimator .estimate .config             \n  <chr>   <chr>          <dbl> <chr>               \n1 rmse    standard       4.33  Preprocessor1_Model1\n2 rsq     standard       0.945 Preprocessor1_Model1\n3 mae     standard       2.69  Preprocessor1_Model1\n```\n:::\n:::\n\n\nVisualize actual vs. predicted compressive strength for final model.\n\n::: {.cell}\n::: {.cell-output-display}\n![](2022-09-24_ConcreteXGB_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n## Summary\nThe XGBoost model to predict the compressive strength of concrete performed better (RMSE = 4.3 MPa, R^2^ = 0.945) than a conventional materials model(RMSE = 7.9 MPa, R^2^ = 0.78).\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}