{
  "hash": "3168aaff958e1c0689e10a08ae51e5c7",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 18: Surface Area of Lava Droplet\"\ndate: 2024-03-11\nexecute: \n  cache: true\n---\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-1_3975d4492b7ca8950e5d914c4e5df5d4'}\n\n:::\n\n\nCalculate surface area of a lava droplet using a breadth-first search approach\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 18. Bits of lava are being ejected from a volcano and you are able to get a scan of a droplet.  The scan contains a 3D grid of 1x1x1 cubes to approximate the shape of the lava droplet.  The speed at which the droplet cools could determine whether it creates obsidian.  The cooling rate will depend upon the surface area of the droplet.  Surface area is determined by the number of exposed cube faces.\n\n## Loading the input file\n\nThe input file contains a file where each line is a series of 3 numbers separated by a comma (e.g. \"13, 6, 3\").  The ```read_lines``` function from the ```readr``` package is used to read the input file.\n\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-2_ffbbd50cf2357b0e7ffd025b00a8c751'}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(collections)\n\nfilepath <- here::here(\"./posts/data/aoc/day18_input.txt\") #\n#filepath <- here::here(\"./posts/data/aoc/day18_test.txt\") #\n\ncubes <- read_lines(filepath, skip_empty_rows = TRUE)\n```\n:::\n\n\n## Part One\n\nWe are first asked to determine the number of cube faces which are not attached to other cubes.  This number can be calculated by first determining the total possible number of faces which is the total number of cubes multiplied by 6 since a cube has 6 faces.  For each cube, the coordinates for each face are determined.  If the face is adjacent to another cube, the face is not part of the surface area and subtracted from the total possible number of faces.\n\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-3_85347599acf0bab3b75778cb278cd4c6'}\n\n```{.r .cell-code}\n#coordinate system can be viewed as lower left corner of cube\nsides <- list(c(-1,  0,  0),\n              c( 1,  0,  0),\n              c( 0, -1,  0),\n              c( 0,  1,  0),\n              c( 0,  0, -1),\n              c( 0,  0,  1))\n\n#total possible side (face) count\nsc <- length(cubes) * 6\n\nfor (cube in cubes) {\n  temp <- as.integer(unlist(str_split(cube, \",\")))\n\n  for (side in sides) {\n    ss <- str_c(temp + side, collapse = \",\")\n    # subtract from total possible if occupied by an adjacent cube\n    if (ss %in% cubes) sc <- sc - 1\n  }\n}\n\nsc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4536\n```\n:::\n:::\n\nThe total surface area calculated in Part One is 4536 units.\n\n## Part Two\n\nThe calculation of surface area in Part One is not quite correct.  This calculation does not take into account the case where the cube face is in an inner pore within the lava droplet.  In this case, this face will not be accessible from outside the droplet and should not be included in the surface area calculation.\n\nI will use a slightly different coordinate system for the cube faces to help with the calculations. In this case, the coordinate indicates the center of the cube and each face will be 0.5 units away from the center.\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-4_5cad7b1aea33499b9c07a9003ac42f9e'}\n\n```{.r .cell-code}\noffsets <- list(c(-0.5,    0,    0),\n                c( 0.5,    0,    0),\n                c(   0, -0.5,    0),\n                c(   0,  0.5,    0),\n                c(   0,    0, -0.5),\n                c(   0,    0,  0.5)) \n```\n:::\n\n\nThe faces are stored in a list and the coordinates are stored in the list name.  The minimum (mx, my, mz) and maximum (Mx, My, Mz) coordinates for the droplet are saved to understand the outer limits around the droplet.\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-5_354c7bc9d97963f8d6a57cf47f404846'}\n\n```{.r .cell-code}\nmx <- my <- mz <- Inf\nMx <- My <- Mz <- -Inf\n\ndroplet <- list()\nfaces <- list()\nn <- 0\n\nfor (cube in cubes) {\n   n <- n + 1\n   cell <- as.numeric(unlist(str_split(cube, \",\")))\n   if (sum(cell == c(4, 5 ,6)) == 3) print(n)\n   droplet <- c(droplet, list(cell))\n   \n   mx <- min(mx, cell[1])\n   my <- min(my, cell[2])\n   mz <- min(mz, cell[3])\n   \n   Mx <- max(Mx, cell[1])\n   My <- max(My, cell[2])\n   Mz <- max(Mz, cell[3])\n   \n   for (offset in offsets) {\n     k <-paste(cell[1] + offset[1], cell[2] + offset[2], cell[3] + offset[3], collapse = \"\")\n     if (!(k %in% names(faces))) {\n       faces[[k]] <- 0\n     }\n     faces[[k]] <- faces[[k]] + 1\n   }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1717\n```\n:::\n:::\n\n\nA breadth-first search is used to determine which coordinates are part of the air around the droplet (not one of the droplet faces).  To begin the search, 1 is subtracted to the minimum coordinates and 1 is added to the maximum coordinates.\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-6_e12db2b3383466df695fb3d65af673bb'}\n\n```{.r .cell-code}\nmx <- mx - 1\nmy <- my - 1\nmz <- mz - 1\n\nMx <- Mx + 1\nMy <- My + 1\nMz <- Mz + 1\n```\n:::\n\n\nThe ```collections``` package is used to create the queue (deque) for storing the coordinates to be explored by the breadth-first search. If the search coordinates are outside the min/max limits then it skips to the next coordinate.  If the search coordinates are part of the droplet then it skips to the next coordinate.  If the search coordinates are already in ```air``` then it skips to the next coordinate otherwise it is appended to the ```air```.\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-7_d27836645b28080f5746f2cf737afc05'}\n\n```{.r .cell-code}\nstart <- Sys.time()\nq <- deque(list(c(mx, my, mz)))\nair <- list(c(mx, my, mz))\n\nwhile (q$size() > 0) {\n  coords <- unlist(q$popleft())\n\n  for (d in offsets) {\n    k <- c(coords[1] + d[1] * 2, coords[2] + d[2] * 2, coords[3] + d[3] * 2)\n    \n    if (!((mx <= k[1]) & (k[1] <= Mx) & (my <= k[2]) & (k[2] <= My) & (mz <= k[3]) & (k[3] <= Mz))) {\n      next\n    }\n    \n    if (sum(droplet %in% list(k)) > 0) next\n    if (sum(air %in% list(k)) > 0) next\n  \n    air <- c(air, list(k))\n    q$push(list(k))\n  }\n}\nend <- Sys.time()\n```\n:::\n\nI tried the ```deque``` function to see whether it would bring any speed advantage over a manual implementation but did not observe any significant improvement.  This breadth-first search took 44 min to run in this implementation.\n\nA ```free``` list is used to contain all of the faces of the air cubes in the same format as for the faces of the droplet cubes.  This code is basically a reformatting of the air list.\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-8_a7120561fe681e6168ba8accf74d17fb'}\n\n```{.r .cell-code}\nfree <- list()\n\nfor (a in air) {\n  for (d in offsets) {\n    k <-paste(a[1] + d[1], a[2] + d[2], a[3] + d[3], collapse = \"\")\n     if (!(k %in% names(free))) {\n       free[[k]] <- 0\n     }\n     free[[k]] <- free[[k]] + 1\n  }\n}\n```\n:::\n\n\nThe surface area of the droplet is then calculated as the cube face coordinates which are in both the droplet(```faces```) and in the air (```free```).\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-9_2f85f109b072933f183c7de0543c5868'}\n\n```{.r .cell-code}\nsurface_area <- 0\n\nfor (face in names(faces)) {\n  if (face %in% names(free)) {\n    surface_area <- surface_area + 1\n  }\n}\n\nsurface_area\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2606\n```\n:::\n:::\n\n\nThe total surface area as corrected in Part Two is 2606 units.  This is a significant correction from 4536 units calculated in Part One.\n\n## Summary\n\nBreadth-first search is used to find the air around a complex droplet surface as a means of calculating surface area.  The ```deque``` function from the ```collections``` package was used to manage the queue which made the code a bit cleaner but didn't improve the speed at all.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-10_9402313c11db68db8b1e8c945dbfd815'}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2024-04-19\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.450 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P collections * 0.3.7   2023-01-05 [?] CRAN (R 4.3.3)\n P readr       * 2.1.5   2024-01-10 [?] CRAN (R 4.3.2)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.3.2)\n P stringr     * 1.5.1   2023-11-14 [?] CRAN (R 4.3.2)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpmWTBJB/renv-use-libpath-1f5854ca799\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.3/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/R-4.3/x86_64-w64-mingw32/7f66d5b3\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}