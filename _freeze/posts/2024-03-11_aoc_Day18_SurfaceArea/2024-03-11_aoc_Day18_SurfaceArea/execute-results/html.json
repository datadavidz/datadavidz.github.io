{
  "hash": "74189bbf3eabadc992688598a437bb04",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 18: Surface Area of Lava Droplet\"\ndate: 2024-03-11\nexecute: \n  cache: true\n---\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-1_0f5229809f7f1cd5fdd473f507f4272e'}\n\n:::\n\n\nCalculate surface area of a lava droplet using a breadth-first search approach\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 18. Bits of lava are being ejected from a volcano and you are able to get a scan of a droplet.  The scan contains a 3D grid of 1x1x1 cubes to approximate the shape of the lava droplet.  The speed at which the droplet cools could determine whether it creates obsidian.  The cooling rate will depend upon the surface area of the droplet.  Surface area is determined by the number of exposed cube faces.\n\n## Loading the input file\n\nThe input file contains a file where each line is a series of 3 numbers separated by a comma (e.g. \"13, 6, 3\").  The ```read_lines``` function from the ```readr``` package is used to read the input file.\n\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-2_d1c203588da51d4cf791dada1b916a3c'}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(collections)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'collections' was built under R version 4.3.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'collections'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:utils':\n\n    stack\n```\n:::\n\n```{.r .cell-code}\nfilepath <- here::here(\"./posts/data/aoc/day18_input.txt\") #\n#filepath <- here::here(\"./posts/data/aoc/day18_test.txt\") #\n\ncubes <- read_lines(filepath, skip_empty_rows = TRUE)\n```\n:::\n\n\n## Part One\n\nWe are first asked to determine the number of cube faces which are not attached to other cubes.  This number can be calculated by first determining the total possible number of faces which is the total number of cubes multiplied by 6 since a cube has 6 faces.  For each cube, the coordinates for each face are determined.  If the face is adjacent to another cube, the face is not part of the surface area and subtracted from the total possible number of faces.\n\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-3_85347599acf0bab3b75778cb278cd4c6'}\n\n```{.r .cell-code}\n#coordinate system can be viewed as lower left corner of cube\nsides <- list(c(-1,  0,  0),\n              c( 1,  0,  0),\n              c( 0, -1,  0),\n              c( 0,  1,  0),\n              c( 0,  0, -1),\n              c( 0,  0,  1))\n\n#total possible side (face) count\nsc <- length(cubes) * 6\n\nfor (cube in cubes) {\n  temp <- as.integer(unlist(str_split(cube, \",\")))\n\n  for (side in sides) {\n    ss <- str_c(temp + side, collapse = \",\")\n    # subtract from total possible if occupied by an adjacent cube\n    if (ss %in% cubes) sc <- sc - 1\n  }\n}\n\nsc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4536\n```\n:::\n:::\n\nPart two:\n\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-4_5cad7b1aea33499b9c07a9003ac42f9e'}\n\n```{.r .cell-code}\noffsets <- list(c(-0.5,    0,    0),\n                c( 0.5,    0,    0),\n                c(   0, -0.5,    0),\n                c(   0,  0.5,    0),\n                c(   0,    0, -0.5),\n                c(   0,    0,  0.5)) \n```\n:::\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-5_354c7bc9d97963f8d6a57cf47f404846'}\n\n```{.r .cell-code}\nmx <- my <- mz <- Inf\nMx <- My <- Mz <- -Inf\n\ndroplet <- list()\nfaces <- list()\nn <- 0\n\nfor (cube in cubes) {\n   n <- n + 1\n   cell <- as.numeric(unlist(str_split(cube, \",\")))\n   if (sum(cell == c(4, 5 ,6)) == 3) print(n)\n   droplet <- c(droplet, list(cell))\n   \n   mx <- min(mx, cell[1])\n   my <- min(my, cell[2])\n   mz <- min(mz, cell[3])\n   \n   Mx <- max(Mx, cell[1])\n   My <- max(My, cell[2])\n   Mz <- max(Mz, cell[3])\n   \n   for (offset in offsets) {\n     k <-paste(cell[1] + offset[1], cell[2] + offset[2], cell[3] + offset[3], collapse = \"\")\n     if (!(k %in% names(faces))) {\n       faces[[k]] <- 0\n     }\n     faces[[k]] <- faces[[k]] + 1\n   }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1717\n```\n:::\n:::\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-6_e12db2b3383466df695fb3d65af673bb'}\n\n```{.r .cell-code}\nmx <- mx - 1\nmy <- my - 1\nmz <- mz - 1\n\nMx <- Mx + 1\nMy <- My + 1\nMz <- Mz + 1\n```\n:::\n\n\nUsing deque with lists\n\n::: {.cell hash='2024-03-11_aoc_Day18_SurfaceArea_cache/html/unnamed-chunk-7_d27836645b28080f5746f2cf737afc05'}\n\n```{.r .cell-code}\nstart <- Sys.time()\nq <- deque(list(c(mx, my, mz)))\nair <- list(c(mx, my, mz))\n\nwhile (q$size() > 0) {\n  coords <- unlist(q$popleft())\n\n  for (d in offsets) {\n    k <- c(coords[1] + d[1] * 2, coords[2] + d[2] * 2, coords[3] + d[3] * 2)\n    \n    if (!((mx <= k[1]) & (k[1] <= Mx) & (my <= k[2]) & (k[2] <= My) & (mz <= k[3]) & (k[3] <= Mz))) {\n      next\n    }\n    \n    if (sum(droplet %in% list(k)) > 0) next\n    if (sum(air %in% list(k)) > 0) next\n  \n    air <- c(air, list(k))\n    q$push(list(k))\n  }\n}\nend <- Sys.time()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}