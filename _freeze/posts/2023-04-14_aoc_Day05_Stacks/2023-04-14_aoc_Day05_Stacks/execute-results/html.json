{
  "hash": "dcd6ef7aab43bc6c16fb8de1e4a05f01",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 5: Stacking Crates\"\ndate: 2023-04-14\n---\n\n::: {.cell}\n\n:::\n\nUsing base R to read a custom, input file format and manipulate the data in lists\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 5. Supplies for the elves' expedition are loaded in crates which are contained in nine stacks.  Unfortunately, the order of the crates in each stack is not correct and a crane operator needs to move the crates between the stacks until all the crates are in the correct order for unloading.\n\n## Loading the input file\n\nThe input file consists of two sections.  The first section contains a visual representation of the positioning of the crates in each of the nine stacks.  The second section contains the instructions for the crane operator to move crates from one stack to another.  The text for the first section is shown below.\n\n```\n[V]     [B]                     [F]\n[N] [Q] [W]                 [R] [B]\n[F] [D] [S]     [B]         [L] [P]\n[S] [J] [C]     [F] [C]     [D] [G]\n[M] [M] [H] [L] [P] [N]     [P] [V]\n[P] [L] [D] [C] [T] [Q] [R] [S] [J]\n[H] [R] [Q] [S] [V] [R] [V] [Z] [S]\n[J] [S] [N] [R] [M] [T] [G] [C] [D]\n 1   2   3   4   5   6   7   8   9 \n```\n\nThe first step is to read the first 8 lines containing the crate locations into character strings.  In this case, the length of the 8 strings are the same which makes it easier to handle.  We also define the position of the crate labels (i.e. letter) as the brackets do not add much other than helping with the visual representation.\n\n::: {.cell}\n\n```{.r .cell-code}\nfilepath <- here::here(\"./posts/data/aoc/day05_input.txt\")\n\nboxlines <- readLines(filepath, n=8L)\n\ncpositions <- c(2, 6, 10, 14, 18, 22, 26, 30, 34)\n```\n:::\n\n\nNext, I defined two functions.  The first function, ```extract_chars``` extracts the letters from one of the strings at the correct positions.  The second function, ```extract_lines``` uses ```extract_chars``` to extract all of the lines and merge into one list containing all nine stack labels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextract_chars <- function(stringToExtract, charPositions) {\n  char_list <- list()\n  for (n in 1:length(charPositions)) {\n    char_list <- c(char_list, substring(stringToExtract, charPositions[n], charPositions[n]))\n  }\n  return(char_list)\n}\n\nextract_lines <- function(stringsToExtract, charPositions) {\n  list1 <- extract_chars(stringsToExtract[1], charPositions)\n  for (i in 2:length(stringsToExtract)) {\n    list2 <- extract_chars(stringsToExtract[i], charPositions)\n    list1 <- mapply(c, list1, list2, SIMPLIFY = FALSE)\n  }\n  return(list1)\n}\n```\n:::\n\n\nThe lines read from the input file and the positions of the crate labels are used as the arguments for ```extract_lines``` to generate the desired list object.\n\n::: {.cell}\n\n```{.r .cell-code}\nbox_lists <- extract_lines(boxlines, cpositions)\n\nstr(box_lists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 9\n $ : chr [1:8] \"V\" \"N\" \"F\" \"S\" ...\n $ : chr [1:8] \" \" \"Q\" \"D\" \"J\" ...\n $ : chr [1:8] \"B\" \"W\" \"S\" \"C\" ...\n $ : chr [1:8] \" \" \" \" \" \" \" \" ...\n $ : chr [1:8] \" \" \" \" \"B\" \"F\" ...\n $ : chr [1:8] \" \" \" \" \" \" \"C\" ...\n $ : chr [1:8] \" \" \" \" \" \" \" \" ...\n $ : chr [1:8] \" \" \"R\" \"L\" \"D\" ...\n $ : chr [1:8] \"F\" \"B\" \"P\" \"G\" ...\n```\n:::\n:::\n\nThe blank spaces need to removed from the character vectors as they are not needed and would only interfere with subsequent manipulations.  A simple for loop is used for this purpose.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(box_lists)) {\n  box_lists[[i]] <- box_lists[[i]][box_lists[[i]] != \" \"]\n}\n\nstr(box_lists)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 9\n $ : chr [1:8] \"V\" \"N\" \"F\" \"S\" ...\n $ : chr [1:7] \"Q\" \"D\" \"J\" \"M\" ...\n $ : chr [1:8] \"B\" \"W\" \"S\" \"C\" ...\n $ : chr [1:4] \"L\" \"C\" \"S\" \"R\"\n $ : chr [1:6] \"B\" \"F\" \"P\" \"T\" ...\n $ : chr [1:5] \"C\" \"N\" \"Q\" \"R\" ...\n $ : chr [1:3] \"R\" \"V\" \"G\"\n $ : chr [1:7] \"R\" \"L\" \"D\" \"P\" ...\n $ : chr [1:8] \"F\" \"B\" \"P\" \"G\" ...\n```\n:::\n:::\n\nThe ```box_lists``` object now has the crates labels for each stack in order from top to bottom.  Now, we need to read the crane operator instructions which is beneath the first section and separated by a blank line.  The script for reading the lines containing the instructions is listed below.  There is a flag, ```start_collecting``` to indicate where the second section begins (after the blank line).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_collecting <- 0\nbox_moves <- list()\nline_number <- 0\n\ncon = file(filepath, \"r\")\nwhile (TRUE) {\n  # line_number <- line_number + 1\n  oneLine = readLines(con, n = 1)\n  # print(oneLine)\n  if (length(oneLine) == 0) {\n    break\n  }\n  if (start_collecting == 0 & nchar(oneLine) == 0) {\n    start_collecting <- 1\n    # print(\"Started collecting\")\n  }\n  if (start_collecting == 1) {\n    if (nchar(oneLine) > 0)  \n    box_moves <- c(box_moves, oneLine)\n  }\n}\nclose(con)\n\nhead(box_moves, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"move 1 from 8 to 4\"\n\n[[2]]\n[1] \"move 1 from 7 to 8\"\n\n[[3]]\n[1] \"move 1 from 6 to 3\"\n\n[[4]]\n[1] \"move 2 from 6 to 5\"\n\n[[5]]\n[1] \"move 8 from 5 to 1\"\n```\n:::\n:::\n\nThe instruction explain how many crates to move and then from which stack and to which stack.  For example, the first instruction listed above indicates to move 1 crate from the top of stack 8 to the top of stack 4. The instructions are parsed so that the numbers can accessed directly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox_moves_parsed <- sapply(box_moves, function(x) strsplit(x, split = \" \"))\n\nhead(box_moves_parsed, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"move\" \"1\"    \"from\" \"8\"    \"to\"   \"4\"   \n\n[[2]]\n[1] \"move\" \"1\"    \"from\" \"7\"    \"to\"   \"8\"   \n\n[[3]]\n[1] \"move\" \"1\"    \"from\" \"6\"    \"to\"   \"3\"   \n\n[[4]]\n[1] \"move\" \"2\"    \"from\" \"6\"    \"to\"   \"5\"   \n\n[[5]]\n[1] \"move\" \"8\"    \"from\" \"5\"    \"to\"   \"1\"   \n```\n:::\n:::\n\n## Moving the Crates\n\nNow that both sections of the input file have been loaded into R objects, the crate operator instructions can be applied.  The input file contained 504 instruction steps!  A new function is created to adjust the stack lists contained in ```box_lists``` based on the instruction step.  An important part, that I initially missed, is that for the first \"9000 model\" crane the crates are moved **one at a time** even when more than one crate is listed in the step.  The top crate is moved and then the subsequent crates one-by-one.  This results in the crates being moved ending up in reverse order on top of the stack they are moved to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply_instruction_step <- function(current_box_lists, move_step, model = \"9000\") {\n  num_boxes <- as.numeric(move_step[2])\n  #print(num_boxes)\n  from_loc <- as.numeric(move_step[4])\n  #print(from_loc)\n  to_loc <- as.numeric(move_step[6])\n  #print(to_loc)\n  if (model == \"9000\") {\n    current_box_lists[[to_loc]] <- c(current_box_lists[[from_loc]][(num_boxes:1)], current_box_lists[[to_loc]])\n  } else {\n    current_box_lists[[to_loc]] <- c(current_box_lists[[from_loc]][(1:num_boxes)], current_box_lists[[to_loc]])\n  }\n  #print(current_box_lists[[to_loc]])\n  current_box_lists[[from_loc]] <- current_box_lists[[from_loc]][-(1:num_boxes)]\n  #print(current_box_lists[[from_loc]])\n  return(current_box_lists)\n}\n```\n:::\n\n\nNow, I run the function for all of the instructions.  Once all steps are completed, the top crate for each stack is identified and the puzzle answer.\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- box_lists\nfor (i in 1:length(box_moves_parsed)) {\n  temp <- apply_instruction_step(temp, box_moves_parsed[[i]], model = \"9000\")\n}\n\n# Show the label for the top crate for each stack\nsapply(temp, '[[', 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S\" \"B\" \"P\" \"Q\" \"R\" \"S\" \"C\" \"D\" \"F\"\n```\n:::\n:::\n\nPart two of the puzzle involves an upgrade of the crane to \"model 9001\".  The new crane can now move multiple boxes instead of one at a time.  So, now the crates are moved in order rather than the reverse order for the \"model 9000\" crane.  We already have built this argument into our ```apply_instruction_step``` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- box_lists\nfor (i in 1:length(box_moves_parsed)) {\n  temp <- apply_instruction_step(temp, box_moves_parsed[[i]], model = \"9001\")\n}\n\n# Show the label for the top crate for each stack\nsapply(temp, '[[', 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"R\" \"G\" \"L\" \"V\" \"R\" \"C\" \"Q\" \"S\" \"B\"\n```\n:::\n:::\n\n## Summary\nThe Day 5 puzzle required quite a bit of thinking about how to load the input file in order to solve the puzzle.  I chose to load the data into strings for manipulation using base R commands.  Initially, I missed the difference between the model 9000 and model 9001 cranes in my first read which led to some head-scratching on why my part one solution wasn't right.  Always read the instructions thoroughly!\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-04-14\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.2.335 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpET91Kg/renv-library-9d037ae2570\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/Temp/RtmpET91Kg/renv-system-library\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}