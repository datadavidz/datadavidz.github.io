{
  "hash": "b00151951ae1135af99f8a6afde306d7",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 4: Separate\"\ndate: 2023-02-07\n---\n\n::: {.cell}\n\n:::\n\nContiguous sections to be cleaned by the elves are parsed from the input file to identify overlapping assignments.\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 4. The contiguous sections for each set of elf cleaning crews is listed as one line separated by a comma.  Each contiguous section for each crew is listed as first section to be cleaned and last section to be cleaned separated by a hyphen.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nfilepath <- here::here(\"./posts/data/aoc/day04_input.txt\")\n\ndata <- read_delim(filepath, delim = \"\\n\", col_names = c(\"assignments\"))\n```\n:::\n\nSo, in the first line, crew 1 is assigned to clean section 31 (i.e. first and last section to be cleaned).  Crew 2 is assigned to clean from section 32 to section 40.  We can parse these input lines using the ```separate``` function from the ```tidyr``` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_data <- data |>\n  separate(assignments, c(\"clean_1\", \"clean_2\"), sep = \",\") |>\n  separate(clean_1, c(\"clean_1_start\", \"clean_1_end\"), sep = \"-\") |>\n  separate(clean_2, c(\"clean_2_start\", \"clean_2_end\"), sep = \"-\") |>\n  mutate_if(is.character, as.integer)\n\nsplit_data |> slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n  clean_1_start clean_1_end clean_2_start clean_2_end\n          <int>       <int>         <int>       <int>\n1            31          31            32          40\n2            26          92            13          91\n3             9          90            29          91\n4            72          72            25          73\n5            28          79            79          79\n```\n:::\n:::\n\n## Solution to Part One\n\nThe first question is to find for how many assignments are the assigned sections for one cleaning crew completely contained within the assigned sections for the other cleaning crew.  For example, if cleaning crew 1 is assigned sections 2-8 and cleaning crew 2 is assigned sections 3-5 then the assignment for crew 2 is contained within the assignment for crew 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap_data <- split_data |>\n  rowwise() |>\n  mutate(overlap = (clean_1_start <= clean_2_start) & (clean_1_end >= clean_2_end) |     #clean 2 contained within clean 1 or\n                   (clean_1_start >= clean_2_start) & (clean_1_end <= clean_2_end)) |>   #clean 1 contained within clean 2\n  ungroup()\n\noverlap_data |> slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  clean_1_start clean_1_end clean_2_start clean_2_end overlap\n          <int>       <int>         <int>       <int> <lgl>  \n1            31          31            32          40 FALSE  \n2            26          92            13          91 FALSE  \n3             9          90            29          91 FALSE  \n4            72          72            25          73 TRUE   \n5            28          79            79          79 TRUE   \n```\n:::\n:::\n\n\n\nYou can then add up all of rows where ```overlap``` is TRUE to find the answer to Part One.\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap_data |>\n  summarize(total_overlaps = sum(overlap))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  total_overlaps\n           <int>\n1            556\n```\n:::\n:::\n\n## Solution to Part Two\n\nThe second question is for how many of the assignments do the sections for crew 1 and crew 2 overlap at all.  The easier way to answer this question is to find the assignments with no overlap.  You just need to check if the ending section for crew 1 is less than the starting section for crew 2 or the ending section for crew 2 is less than the starting section for crew 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npartial_overlap_data <- split_data |>\n  rowwise() |>\n  mutate(no_overlap = (clean_1_end < clean_2_start) | (clean_2_end < clean_1_start)) |>\n  ungroup()\n\npartial_overlap_data |> slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  clean_1_start clean_1_end clean_2_start clean_2_end no_overlap\n          <int>       <int>         <int>       <int> <lgl>     \n1            31          31            32          40 TRUE      \n2            26          92            13          91 FALSE     \n3             9          90            29          91 FALSE     \n4            72          72            25          73 FALSE     \n5            28          79            79          79 FALSE     \n```\n:::\n:::\n\nYou can then add up all the rows where ```no_overlap``` is TRUE and subtract from the total number of rows (assignments).\n\n::: {.cell}\n\n```{.r .cell-code}\npartial_overlap_data |>\n  summarize(total_partial_overlap = nrow(partial_overlap_data) - sum(no_overlap))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  total_partial_overlap\n                  <int>\n1                   876\n```\n:::\n:::\n\n\n## Summary\nThe problem for Day 4 was pretty straightforward in implementing the logical tests once the input data was tidied.  The ```separate``` function made it easy to parse the input data into a tibble and then perform row-wise calculations.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-02-07\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.2.269 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P dplyr       * 1.0.10  2022-09-01 [?] CRAN (R 4.2.2)\n P forcats     * 0.5.2   2022-08-19 [?] CRAN (R 4.2.2)\n P ggplot2     * 3.3.6   2022-05-03 [?] CRAN (R 4.2.1)\n   purrr       * 0.3.5   2022-10-06 [2] CRAN (R 4.2.1)\n   readr       * 2.1.3   2022-10-01 [2] CRAN (R 4.2.1)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n P tibble      * 3.1.8   2022-07-22 [?] CRAN (R 4.2.1)\n   tidyr       * 1.2.1   2022-09-08 [2] CRAN (R 4.2.1)\n P tidyverse   * 1.3.2   2022-07-18 [?] CRAN (R 4.2.1)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpGugBWK/renv-library-38782e7835ab\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/Temp/RtmpGugBWK/renv-system-library\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}