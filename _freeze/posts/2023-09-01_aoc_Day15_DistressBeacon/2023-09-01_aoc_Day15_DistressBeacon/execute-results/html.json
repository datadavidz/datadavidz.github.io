{
  "hash": "1a65b182cea033b1d5a87ad3b62d1334",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 15: Distress Beacon\"\ndate: 2023-09-01\n---\n\n::: {.cell}\n\n:::\n\n\nLocating the position of a distress beacon using Manhattan distance from sensors\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 15.  The locations for sensors and the closest beacon to each sensor is provided.  None of the beacons identified are in distress.  The goal is to use this data to find to location of the beacon sending the distress signal.\n\n## Loading the input file\n\nThe data is read into strings using ```read_lines``` from the ```readr``` package which has the handy option to ignore the blank rows.  In addition, any white space before or after the packet is removed using ```str_trim```.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(purrr)\n\nfilepath <- here::here(\"./posts/data/aoc/day15_input.txt\")\n\nbeacons <- read_lines(filepath, skip_empty_rows = TRUE)\nbeacons <- str_trim(beacons)\nhead(beacons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Sensor at x=3289936, y=2240812: closest beacon is at x=3232809, y=2000000\"\n[2] \"Sensor at x=30408, y=622853: closest beacon is at x=-669401, y=844810\"    \n[3] \"Sensor at x=3983196, y=3966332: closest beacon is at x=3232807, y=4625568\"\n[4] \"Sensor at x=929672, y=476353: closest beacon is at x=-669401, y=844810\"   \n[5] \"Sensor at x=1485689, y=3597734: closest beacon is at x=1951675, y=3073734\"\n[6] \"Sensor at x=69493, y=1886070: closest beacon is at x=-669401, y=844810\"   \n```\n:::\n:::\n\nThe only important information are the numbers indicating the sensor and closest beacon positions. We strip the other characters using some ```stringr``` functions and then convert each line to a numeric vector.\n\n::: {.cell}\n\n```{.r .cell-code}\nlocs <- str_remove(beacons, \"Sensor at \") |>\n  str_replace(\": closest beacon is at \", \" \") |>\n  str_replace_all(\"x=\", \"\") |>\n  str_replace_all(\", y=\", \" \") |>\n  str_split(\" \")\n\nlocs <- map(locs, \\(x) as.numeric(x))\nhead(locs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 3289936 2240812 3232809 2000000\n\n[[2]]\n[1]   30408  622853 -669401  844810\n\n[[3]]\n[1] 3983196 3966332 3232807 4625568\n\n[[4]]\n[1]  929672  476353 -669401  844810\n\n[[5]]\n[1] 1485689 3597734 1951675 3073734\n\n[[6]]\n[1]   69493 1886070 -669401  844810\n```\n:::\n:::\n\n## Part One: Searching one y location\n\nThe goal of part one is to focus on one y location (y = 2000000) and determine all of the x locations where the distress beacon **cannot** be located.  These locations can be determined from the input data considering that the sensors are identifying the close beacon and, therefore, the locations closer cannnot contain a beacon.  Two helper functions are set up first to measure the Manhattan distance between a sensor and a beacon and to measure the distance between a sensor and the line forming the y location.\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_beacon_distance <- function(b_vctr) {\n  dist <- abs(b_vctr[1:2] - b_vctr[3:4])\n  dist <- sum(dist)\n  return(dist)\n}\nfind_dist_from_y <- function(b_vctr, y = 10) {\n  dist <- abs(b_vctr[2] - y)\n  return(dist)\n}\n```\n:::\n\n\nNext, we loop through the sensor-beacon locations to find the where the distress beacon cannot be located.  Initially, I saved all of the locations in a list but it becomes a very large amount of locations quickly.  The \"not\" locations were in a consecutive sequence so it is only needed to save the starting and ending locations.\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_beacon <- list()\ny_loc <- 2000000\n\nfor (i in 1:length(locs)){\n  b_dist <- find_beacon_distance(locs[[i]])\n  y_dist <- find_dist_from_y(locs[[i]], y_loc)\n  \n  if (b_dist > y_dist) {\n    start_loc <- locs[[i]][1] - (b_dist - y_dist)\n    end_loc <- locs[[i]][1] + (b_dist - y_dist)\n    not_beacon <- c(not_beacon, list(c(start_loc, end_loc)))\n    #this took too long\n    # for (j in start_loc:end_loc) {\n    #   if (!(list(c(j, y_loc)) %in% not_beacon)) not_beacon <- c(not_beacon, list(c(j, y_loc)))\n    # }\n  }\n}\nhead(not_beacon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 3232809 3347063\n\n[[2]]\n[1]  485789 1373555\n\n[[3]]\n[1] -1596731  1735717\n\n[[4]]\n[1] 2909111 3153777\n\n[[5]]\n[1]  811351 1603969\n\n[[6]]\n[1]  768183 2801607\n```\n:::\n:::\n\nIt is easier to count the number of locations if the start/end locations are listed in order.  The reason is that the location spans can overlap so we don't want to count a specific location more than once.\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_beacon <- not_beacon[order(map_vec(not_beacon, ~ .[[1]]))]\nhead(not_beacon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] -1596731  1735717\n\n[[2]]\n[1]  485789 1373555\n\n[[3]]\n[1]  768183 2801607\n\n[[4]]\n[1]  811351 1603969\n\n[[5]]\n[1] 1811141 3232809\n\n[[6]]\n[1] 2053947 2468477\n```\n:::\n:::\n\nThe \"not beacon\" locations are then processed to find the total number.  Anticipating part two, the interval for these positions is saved rather than counting the total number of positions.\n\n::: {.cell}\n\n```{.r .cell-code}\ncur_loc <- not_beacon[[1]][1]-1\nintervals <- list()\nq <- 0\n\nfor (i in 1:length(not_beacon)) {\n  if (cur_loc > not_beacon[[i]][2]) {\n    #skip\n  } else if (cur_loc < not_beacon[[i]][1]) {\n    cur_loc <- not_beacon[[i]][2]\n    q <- q + 1\n    intervals[[q]] <- c(not_beacon[[i]][1], not_beacon[[i]][2])\n  } else if (cur_loc == not_beacon[[i]][1]) {\n    cur_loc <- not_beacon[[i]][2]\n    intervals[[q]] <- c(intervals[[q]][1], not_beacon[[i]][2])\n  } else {\n    #current point is between start and end point\n    cur_loc <- not_beacon[[i]][2]\n    intervals[[q]] <- c(intervals[[q]][1], not_beacon[[i]][2])\n  }\n}\nintervals\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] -1596731  4679191\n```\n:::\n:::\n\nThe total number of positions is found by the difference between the start and end of the interval.  We also need to subtract any beacons located on the line (which will also be within the interval).\n\n::: {.cell}\n\n```{.r .cell-code}\nbeacon_yloc <- locs[map_lgl(locs, ~ .[[4]] == y_loc)]\npaste(\"The total number of positions where the beacon cannot be located:\", \n      intervals[[1]][2] - intervals[[1]][1] - length(unique(map_vec(beacon_yloc, ~ .[[3]]))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The total number of positions where the beacon cannot be located: 6275921\"\n```\n:::\n:::\n\n## Part Two: Find the distress beacon location\n\nAs anticipated, we now need to find the location of the distress location.  Our device has determined the location is between 0 and 4000000 in both the x and y directions.  We can use mostly the same code developed in Part One but now we need to loop through many y \"lines\".  I did this part in one script which is not the best way but it worked after a bit of troubleshooting.  It is important to not aggregate data that is not needed to answer the question.  The critical piece of information are the intervals.  The y location with 2 intervals separated by one position identifies the location of the distress beacon.\n\n::: {.cell hash='2023-09-01_aoc_Day15_DistressBeacon_cache/html/unnamed-chunk-9_6f27d094aae1e26b5f3ab1c6b4925ba6'}\n\n```{.r .cell-code}\ny_lo <- 0\ny_hi <- 4000000\nall_intervals <- list()\n\n\nfor (j in y_lo:y_hi) {\n  not_beacon <- list()\n  for (i in 1:length(locs)){\n    b_dist <- find_beacon_distance(locs[[i]])\n    y_dist <- find_dist_from_y(locs[[i]], j)\n    \n    if (b_dist > y_dist) {\n      #print(i)\n      start_loc <- locs[[i]][1] - (b_dist - y_dist)\n      end_loc <- locs[[i]][1] + (b_dist - y_dist)\n      not_beacon <- c(not_beacon, list(c(start_loc, end_loc)))\n    }\n  }\n  not_beacon <- not_beacon[order(sapply(not_beacon, '[[', 1))]\n  \n  cur_loc <- not_beacon[[1]][1]-1\n  intervals <- list()\n  q <- 0\n  \n  for (k in 1:length(not_beacon)) {\n    if (cur_loc > not_beacon[[k]][2]) {\n      #skip\n    } else if (cur_loc < not_beacon[[k]][1]) {\n      cur_loc <- not_beacon[[k]][2]\n      q <- q + 1\n      intervals[[q]] <- c(not_beacon[[k]][1], not_beacon[[k]][2])\n    } else if (cur_loc == not_beacon[[k]][1]) {\n      cur_loc <- not_beacon[[k]][2]\n      intervals[[q]] <- c(intervals[[q]][1], not_beacon[[k]][2])\n    } else {\n      #current point is between start and end point\n      cur_loc <- not_beacon[[k]][2]\n      intervals[[q]] <- c(intervals[[q]][1], not_beacon[[k]][2])\n    }\n  }\n  if (length(intervals) > 1) {\n    all_intervals <- list(intervals, j)\n  }\n}\n```\n:::\n\n\nThe solution to Part Two asks for the x location multiplied by 4000000 plus the y location.\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste(\"The location of the distress beacon is: x =\", all_intervals[[1]][[1]][2] + 1, \"y =\", all_intervals[[2]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The location of the distress beacon is: x = 2936793 y = 3442119\"\n```\n:::\n\n```{.r .cell-code}\nprint(paste(\"The Part Two solution is:\",\n            format((all_intervals[[1]][[1]][2] + 1) * 4000000 + all_intervals[[2]], scientific = FALSE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The Part Two solution is: 11747175442119\"\n```\n:::\n:::\n\n## Summary\n\nFiguring out the logic to find the distress beacon from the input data was the main challenge for the Day 15 challenge.  Using lists and some of the ```purrr``` map functions helped streamline the code.  Breaking out some of the last script into helper functions would have helped with readability and troubleshooting.  I needed to avoid aggregating and storing intermediate information in order to loop through all 4000000 lines in Part Two.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-09-01\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.353 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P purrr       * 1.0.1   2023-01-10 [?] CRAN (R 4.2.3)\n P readr       * 2.1.4   2023-02-10 [?] CRAN (R 4.2.3)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/Rtmpk9CTa6/renv-use-libpath-2418356e68d2\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/R-4.2/x86_64-w64-mingw32/30182023\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}