{
  "hash": "b9a6aa2af2477cdfc8033eed53c8e936",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 14: Falling Sand\"\ndate: 2023-08-09\n---\n\n::: {.cell}\n\n:::\n\n\nCreating a recursive function to track the path of falling sand in a cavern\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 14.  In this problem, you scan a cavern with a device which provides you with the rock structure.  Sand is falling from a specific location at the top of the cavern.  Sand collects on the rocks as it descends into the cavern until reaching the edge of cavern where it falls into an abyss.  You are provided a map of the rocks which are represented as points which are connected by straight horizontal or vertical lines as shown below:\n\n```\n498,4 -> 498,6 -> 496,6\n503,4 -> 502,4 -> 502,9 -> 494,9\n```\n\nWhich can be used to generate a map as shown below:\n```\n  4     5  5\n  9     0  0\n  4     0  3\n0 ......+...\n1 ..........\n2 ..........\n3 ..........\n4 ....#...##\n5 ....#...#.\n6 ..###...#.\n7 ........#.\n8 ........#.\n9 #########.\n```\n\nWhere \".\" are open spaces and \"#\" are representing the rock structure.  The sand comes out in units which fall straight down until it hits a rock or another sand unit.  If it is blocked, the sand unit will try to go diagonally down and to the left.  If still blocked, the sand unit will try to go diagonally down and the right.  If all three directions are blocked, the sand comes to rest at its current location and is marked with an \"o\".  If the sand goes past the furthest rock mapped to the left or right then it falls into the abyss.\n\n## Loading the input file\n\nThe data is read into strings using ```read_lines``` from the ```readr``` package which has the handy option to ignore the blank rows.  In addition, any white space before or after the packet is removed using ```str_trim```.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(purrr)\n\nfilepath <- here::here(\"./posts/data/aoc/day14_input.txt\") \n\nrocks <- read_lines(filepath, skip_empty_rows = TRUE)\nrocks <- str_trim(rocks)\nhead(rocks)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"494,132 -> 494,134 -> 487,134 -> 487,139 -> 502,139 -> 502,134 -> 499,134 -> 499,132\"                                                                                                                                                                                      \n[2] \"509,82 -> 514,82\"                                                                                                                                                                                                                                                          \n[3] \"511,113 -> 511,116 -> 509,116 -> 509,120 -> 522,120 -> 522,116 -> 516,116 -> 516,113\"                                                                                                                                                                                      \n[4] \"493,36 -> 493,33 -> 493,36 -> 495,36 -> 495,35 -> 495,36 -> 497,36 -> 497,33 -> 497,36 -> 499,36 -> 499,35 -> 499,36 -> 501,36 -> 501,34 -> 501,36 -> 503,36 -> 503,34 -> 503,36 -> 505,36 -> 505,26 -> 505,36 -> 507,36 -> 507,31 -> 507,36 -> 509,36 -> 509,33 -> 509,36\"\n[5] \"527,101 -> 527,99 -> 527,101 -> 529,101 -> 529,98 -> 529,101 -> 531,101 -> 531,92 -> 531,101 -> 533,101 -> 533,91 -> 533,101 -> 535,101 -> 535,99 -> 535,101 -> 537,101 -> 537,100 -> 537,101 -> 539,101 -> 539,93 -> 539,101\"                                             \n[6] \"493,36 -> 493,33 -> 493,36 -> 495,36 -> 495,35 -> 495,36 -> 497,36 -> 497,33 -> 497,36 -> 499,36 -> 499,35 -> 499,36 -> 501,36 -> 501,34 -> 501,36 -> 503,36 -> 503,34 -> 503,36 -> 505,36 -> 505,26 -> 505,36 -> 507,36 -> 507,31 -> 507,36 -> 509,36 -> 509,33 -> 509,36\"\n```\n:::\n:::\n\nThe idea was to save each rock structure in its own list where each list element would contain the horizontal and vertical coordinate points in a vector.  Three steps are required to create this data structure: 1) remove the arrows (\"->\") and replace with a single space, 2) split the coordinate pairs into their own lists and 3) reformat each coordinate pair string into a numeric vector.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove the arrows\nstructure <- list()\nfor (rock in rocks) {\n  structure <- c(structure, unlist(str_replace_all(rock, \" -> \", \" \")))\n}\n# Split the coordinate pairs into their own lists\nfor (i in 1:length(structure)) {\n  structure[[i]] <- str_split(structure[[i]], \" \")\n}\n# Reformat the coordinate pairs into numeric vectors\nfor (i in 1:length(structure)) {\n  structure[[i]] <- str_split(unlist(structure[[i]]), \",\")\n  structure[[i]] <- map(structure[[i]], function(x) as.numeric(x))\n}\nstructure[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 494 132\n\n[[2]]\n[1] 494 134\n\n[[3]]\n[1] 487 134\n\n[[4]]\n[1] 487 139\n\n[[5]]\n[1] 502 139\n\n[[6]]\n[1] 502 134\n\n[[7]]\n[1] 499 134\n\n[[8]]\n[1] 499 132\n```\n:::\n:::\n\n## Part One: Falling into the Abyss\n\nIn Part One, the coordinates in the input file define the overall map size.  If the sand travels outside this map, it falls into the \"abyss\".  The goal of this part is to determine how many units of sand fall before sand begins to fall into the abyss.  The first step is to determine the size of the map.\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_size <- list(min_x = 9999, max_x = 0, min_y = 9999, max_y = 0)\n\nfor (i in 1:length(structure)) {\n  for (j in 1: length(structure[[i]])) {\n    if (structure[[i]][[j]][1] < map_size[[\"min_x\"]]) {\n      map_size[[\"min_x\"]] <- structure[[i]][[j]][1]\n    } else if (structure[[i]][[j]][1] > map_size[[\"max_x\"]]) {\n      map_size[[\"max_x\"]] <-structure[[i]][[j]][1]\n    } else {\n      #do nothing\n    }\n    \n    if (structure[[i]][[j]][2] < map_size[[\"min_y\"]]) {\n      map_size[[\"min_y\"]] <- structure[[i]][[j]][2]\n    } else if (structure[[i]][[j]][2] > map_size[[\"max_y\"]]) {\n      map_size[[\"max_y\"]] <-structure[[i]][[j]][2]\n    } else {\n      #do nothing\n    } \n  }\n}\nmap_size\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$min_x\n[1] 483\n\n$max_x\n[1] 554\n\n$min_y\n[1] 14\n\n$max_y\n[1] 164\n```\n:::\n:::\n\nThe minimum and maximum values can then be used to construct a matrix to serve as a map for the rock structures where the x coordinates correspond to columns and y coordinates correspond to rows.  The matrix is initiated with \".\" characters and the rock structure is indicated with \"#\" characters.\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_rows <- map_size[[\"max_y\"]] + 1  #because the first column is \"0\" \nnum_cols <- map_size[[\"max_x\"]] - map_size[[\"min_x\"]] + 1\n\nblank_map <- matrix(rep(\".\", num_rows*num_cols), nrow = num_rows, ncol = num_cols)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrock_map <- blank_map\n\nfor (i in 1:length(structure)) {\n  for (j in 1:(length(structure[[i]])-1)) {\n    start_pt <- structure[[i]][[j]]\n    end_pt <- structure[[i]][[j+1]]\n    for (m in start_pt[1]:end_pt[1]) {\n      for(n in start_pt[2]:end_pt[2]) {\n        rock_map[n+1, m-map_size[[\"min_x\"]]+1] <- \"#\"\n      }\n    } \n  }\n}\n```\n:::\n\n\nPlot the map\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nplot_start <- rock_map |> \n  as_tibble() |>\n  mutate(row_id = row_number()) |>\n  pivot_longer(cols = starts_with(\"V\"), names_to = \"name\", values_to = \"value\") |>\n  mutate(col_id = as.integer(sub(\"V\", \"\", name)))|>\n  select(row_id, col_id, value)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- plot_start |>\n  rowwise() |>\n  mutate(rock = ifelse(value == \"#\", \"yes\", \"no\")) |>\n  ungroup() |>\n  ggplot(aes(x = col_id, y = row_id, label = value, color = factor(rock))) +\n    geom_text() +\n    scale_y_reverse() +\n    theme_void() +\n    theme(legend.position = \"none\") +\n    scale_color_manual(values = c(\"#D3D3D3\", \"#3D3D3D\"))\np1\n```\n\n::: {.cell-output-display}\n![](2023-08-09_aoc_Day14_FallingSand_files/figure-html/unnamed-chunk-8-1.png){width=864}\n:::\n:::\n\n\nFinding the resting locations for each sand unit is performed using a recursive function.  The recursive function helps in these cases where the number of steps in any direction are difficult to calculate upfront.  Here, we can just code the different options and send the new location back to the function until it finds its resting spot.  An ```overflow```\n\n::: {.cell}\n\n```{.r .cell-code}\nfalling_sand <- function(c_loc, r_map) {\n  #try down\n  if (r_map[c_loc[1]+1, c_loc[2]] == \".\") {\n    return(falling_sand(c(c_loc[1]+1, c_loc[2]), r_map))\n  } else {\n    #try left\n    if (c_loc[2]-1 < 1) return(list(r_map, overflow = TRUE))\n    if (r_map[c_loc[1]+1, c_loc[2]-1] == \".\")  {\n      return(falling_sand(c(c_loc[1]+1, c_loc[2]-1), r_map))\n    } else {\n      #try right\n      if(c_loc[2]+1 > ncol(r_map)) return(list(r_map, overflow = TRUE))\n      if (r_map[c_loc[1]+1, c_loc[2]+1] == \".\") {\n        return(falling_sand(c(c_loc[1]+1, c_loc[2]+1), r_map))\n      } else {\n        r_map[c_loc[1], c_loc[2]] <- \"o\"\n      }\n    }\n  }\n  return(list(r_map, overflow = FALSE))\n}\n```\n:::\n\n\nNow, the falling of the sand begins!  We initiate units of sand until the sand falls into the abyss (overflow = TRUE).  A counter is also included to determine then number of sand units dropped and also to try to avoid an infinite loop. \n\n::: {.cell}\n\n```{.r .cell-code}\nloop_count <- 0\ntemp <- list(rock_map, overflow = FALSE)\n\nwhile (temp[[\"overflow\"]] == FALSE & loop_count < 10000) {\n  loop_count <- loop_count + 1\n  temp <- falling_sand(c(1, 500-map_size[[\"min_x\"]]+1), temp[[1]])\n}\n\nprint(paste(\"Sand bags dropped = \", loop_count-1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Sand bags dropped =  1016\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data <- temp[[1]] |> \n  as_tibble() |>\n  mutate(row_id = row_number()) |>\n  pivot_longer(cols = starts_with(\"V\"), names_to = \"name\", values_to = \"value\") |>\n  mutate(col_id = as.integer(sub(\"V\", \"\", name)))|>\n  select(row_id, col_id, value)\n\np2 <- plot_data |>\n  ggplot(aes(x = col_id, y = row_id, label = value, color = factor(value))) +\n    geom_text() +\n    scale_y_reverse() +\n    theme_void() +\n    theme(legend.position = \"none\") +\n    scale_color_manual(values = c(\"#3D3D3D\", \"#D3D3D3\", \"#B3AC85\"))\np2\n```\n\n::: {.cell-output-display}\n![](2023-08-09_aoc_Day14_FallingSand_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n## Part Two: The Hidden Cave Floor\n\nIn Part Two, we realize that there isn't actually an abyss but rather there is a cavern floor which extends two coordinates below the lowest rock structure in the map.  The floor is assumed to extend endlessly in both directions.  The goal of part two is to find out how many sand units fall until the inlet for the sand will be clogged.  It is straightforward to increase the number of rows by two for the cavern floor but how to determine the number of columns required?  The maximum size will be a triangle down to the bottom row which can be figured as twice the number of rows plus 1 (actually 2 less is required since the inlet is clogged on the second row).\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_rows <- map_size[[\"max_y\"]] + 3  #because the first column is \"0\" \nnum_cols <- (num_rows * 2) + 1\n\nblank_map <- matrix(rep(\".\", num_rows*num_cols), nrow = num_rows, ncol = num_cols)\n```\n:::\n\n\nThe rock map is created in the same manner as in Part One however the rock line at the bottom needs to be added for the cavern floor.\n\n::: {.cell}\n\n```{.r .cell-code}\nrock_map <- blank_map\n\nfor (i in 1:length(structure)) {\n  for (j in 1:(length(structure[[i]])-1)) {\n    start_pt <- structure[[i]][[j]]\n    end_pt <- structure[[i]][[j+1]]\n    for (m in start_pt[1]:end_pt[1]) {\n      for(n in start_pt[2]:end_pt[2]) {\n        rock_map[n+1, m-num_cols+3] <- \"#\"\n      }\n    } \n  }\n}\n#Add the line at the bottom\nfor (i in 1:num_cols) {\n  rock_map[num_rows, i] <- \"#\"\n}\n```\n:::\n\n\nA similar recursive function is used but with a different meaning for \"overflow\".  In this case, overflow means that the sand outlet is clogged rather than sand falling into the abyss.  The modifications are shown below.\n\n::: {.cell}\n\n```{.r .cell-code}\nfalling_sand2 <- function(c_loc, r_map) {\n  #check if outlet is clogged\n  if (r_map[1, 168] == \"o\") {\n    return(list(r_map, overflow = TRUE))\n  } else {\n    #try down\n    if (r_map[c_loc[1]+1, c_loc[2]] == \".\") {\n    return(falling_sand2(c(c_loc[1]+1, c_loc[2]), r_map))\n    } else {\n      #try left\n      #if (c_loc[2]-1 < 1) return(list(r_map, overflow = TRUE))\n      if (r_map[c_loc[1]+1, c_loc[2]-1] == \".\")  {\n        return(falling_sand2(c(c_loc[1]+1, c_loc[2]-1), r_map))\n      } else {\n        #try right\n        #if(c_loc[2]+1 > ncol(r_map)) return(list(r_map, overflow = TRUE))\n        if (r_map[c_loc[1]+1, c_loc[2]+1] == \".\") {\n          return(falling_sand2(c(c_loc[1]+1, c_loc[2]+1), r_map))\n        } else {\n          r_map[c_loc[1], c_loc[2]] <- \"o\"\n        }\n      }\n    }\n  }\n  return(list(r_map, overflow = FALSE))\n}\n```\n:::\n\n\nAs before, we loop through the sand units until the overflow condition is met.\n\n::: {.cell}\n\n```{.r .cell-code}\nloop_count <- 0\ntemp <- list(rock_map, overflow = FALSE)\n\nwhile (temp[[\"overflow\"]] == FALSE & loop_count < 50000) {\n  loop_count <- loop_count + 1\n  temp <- falling_sand2(c(1, 500-num_cols+3), temp[[1]])\n}\n\nprint(paste(\"Sand bags dropped = \", loop_count-1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Sand bags dropped =  25402\"\n```\n:::\n:::\n\n## Summary\n\nOverall, the Day 14 puzzle required a lot of work to read the input file, figure out how to create the map and then figure out the number of falling sand units.  The recursive function worked well for determining the resting location for each sand unit.  One source of frustration was keeping track of the x coordinate as column and y coordinate as row since the order of parameters is reversed in the matrix location.\n\n\n::: {.cell}\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-08-28\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.353 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P dplyr       * 1.1.2   2023-04-20 [?] CRAN (R 4.2.3)\n P ggplot2     * 3.4.2   2023-04-03 [?] CRAN (R 4.2.3)\n P purrr       * 1.0.1   2023-01-10 [?] CRAN (R 4.2.3)\n P readr       * 2.1.4   2023-02-10 [?] CRAN (R 4.2.3)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n P tidyr       * 1.3.0   2023-01-24 [?] CRAN (R 4.2.3)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpC2OBmC/renv-use-libpath-28784a38268a\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/R-4.2/x86_64-w64-mingw32/30182023\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [
      "2023-08-09_aoc_Day14_FallingSand_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}