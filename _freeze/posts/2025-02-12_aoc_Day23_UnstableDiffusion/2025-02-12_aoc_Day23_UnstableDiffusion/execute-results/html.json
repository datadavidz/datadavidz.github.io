{
  "hash": "4c4945a6f9006ff249125a100fa116ab",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code Day 23: Unstable Diffusion\"\ndate: 2025-02-12\n---\n\n::: {.cell}\n\n:::\n\n\n\nOptimize runtime of code using duplicated instead of %in%\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/2022).  In this puzzle, the elves are ready to plant their star fruit and they need to spread out.  You have a map of their current locations.  There is a set of rules for their movement.  If no other elves are in any of the 8 cardinal directions, the elf stays put.  If there is another elf present, the elf attempts to move N, S, W and E in that order.  Before moving the elf checks for another elf in that direction and the two adjacent cardinal directions.  For example, before moving north the elf checks N, NW and NE for another elf.  If an elf is present, the elf tries the next direction (S, in this case) and so on.  However, if more than one elf choses to move to a space, neither of the elves will move.\n\nYour goal in Part 1 is to find the number of empty spaces on the map after 10 rounds.  After each round, the order of the movement shifts forward by one (e.g. N-S-W-E becomes S-W-E-N).  Since the available area is able to increase indefinitely as the elves move, the rectangular border for calculating the empty spaces is bounded by the furthest elf in each direction.  An example map is shown below with the elves shown with \"#\" and empty spaces as \".\".\n\n```\n....#..\n..###.#\n#...#.#\n.#...##\n#.###..\n##.#.##\n.#..#..\n```\n\n## Loading the input file\n\nThe `read_lines` function from the `readr` package is used to read the input file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\n\nfilepath <- here::here(\"./posts/data/aoc/day23_input.txt\")\n#filepath <- here::here(\"./posts/data/aoc/day23_test.txt\")\n\ninput_map <- read_lines(filepath, skip_empty_rows = FALSE)\n```\n:::\n\n\n\nThe map is transformed into a list containing the row and column position for each elf as a numeric vector.  The input file contains 2757 elves which are contained in a list of the same length.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelves <- list()\n\nfor (i in 1:length(input_map)) {\n  map_row <- str_split_1(input_map[i], \"\")\n  for (j in 1:length(map_row)) {\n    if (map_row[j] == \"#\") {\n      elves <- c(elves, list(as.numeric(c(i, j))))\n    }  \n  }\n}\n```\n:::\n\n\n\nSeveral variables are set up for the order of movement, movements, neighbors to check and the positions to scan before making a move.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#order of movement\nord <- c(\"n\", \"s\", \"w\", \"e\")\n\n#moves (added to current position)\nmoves <- list(n = c(-1, 0),\n            s = c(1, 0),\n            w = c(0, -1),\n            e = c(0, 1))\n\n#adjacent positions in 8 cardinal directions - neighbors\nnbr <- list(c(-1,-1), c(-1,0), c(-1,1),\n     c(0,-1), c(0, 1),\n     c(1, -1), c(1, 0), c(1,1))\n\n#scan for each direction\nscanmap <- list(n = list(c(-1,-1), c(-1, 0), c(-1, 1)),\n            s = list(c(1, -1), c(1, 0), c(1, 1)),\n            w = list(c(-1, -1), c(0, -1), c(1, -1)),\n            e = list(c(-1, 1), c(0, 1), c(1, 1)))\n```\n:::\n\n\n\n## Part 1 Solution\n\nA loop is set up to determine the moves for each round.  The code checks if any elves in adjacent positions are present (neighbors), if not then no move is necessary and next elf is tested.  If at least one elf is present, it checks the positions in different directions in order to determine which move to make.  If an open move is found, it checks if it has been already made once or twice already.\n\nThe second part of the code repeats the loop but actually makes the move by updating the elves position, if the move is not to the same position as one or more other elves.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#number of rounds\nnr <- 10\n\nfor (rounds in 1:nr) {\n  print(paste(\"Round\", rounds, \": \", Sys.time()))\n  once <- list()\n  twice <- list()\n  prop <- list()\n  \n  for (elf in elves) {\n    #check if any neighbors present\n    if (!any(lapply(nbr, function(x) x + elf) %in% elves)) next\n    \n    #check directions in order until a move is found\n    for (d in ord) {\n      #print(d)\n      test <- lapply(lapply(scanmap[[d]], '[', 1:2), function(x) x + elf)\n      \n      #moves to the same spot are saved      \n      if (!any(test %in% elves)) {\n        prop <- list(c(elf + moves[[d]]))\n        #print(prop)\n        if (prop %in% twice) {\n          #do nothing\n        } else if (prop %in% once) {\n          twice <- c(twice, prop)\n        } else {\n          once <- c(once, prop)\n        }\n        break\n      }\n    }\n  }\n  #cache the current elves' positions\n  ec <- elves\n  \n  for (i in 1:length(ec)) {\n    #check for neighbors\n    if (!any(lapply(nbr, function(x) x + ec[[i]]) %in% ec)) next\n    \n    #check each direction in order\n    for (d in ord) {\n      test <- lapply(lapply(scanmap[[d]], '[', 1:2), function(x) x + ec[[i]])\n      \n      if (!any(test %in% ec)) {\n        \n        prop <- list(c(ec[[i]] + moves[[d]]))\n        #update the elf position if only elf to move to this position in this round\n        if (!(prop %in% twice)) {\n          #update the position\n          elves[[i]] <- unlist(prop)\n        } \n        break\n      }\n    }\n  }\n  #update the order of movement directions\n  ord <- c(ord[2:4], ord[1])\n}\n```\n:::\n\n\n\nThe puzzle solution is found by determining the smallest rectangle which contains all of the elves.  The number of empty spaces is then determined by subtracting the total number of elves (length of elves list) from the total possible positions (area = length * width).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_y <- min(sapply(elves, '[[', 1))\nmax_y <- max(sapply(elves, '[[', 1))\nmin_x <- min(sapply(elves, '[[', 2))\nmax_x <- max(sapply(elves, '[[', 2)) \n\n(max_y - min_y + 1) * (max_x - min_x + 1) - length(elves)\n```\n:::\n\n\n\nThe total empty spaces after 10 rounds was 4049 for the input file.  The code to update positions for each round as shown above was very slow.  Each round took ~5 min to execute which could be managed for 10 rounds but further optimization will be necessary for Part 2.\n\n## Part 2 Solution\n\nFor part 2, the question is how many rounds are required before the elves stop spreading out.  In this case, the number of rounds will be greater than 10 and checking other solutions online the number of rounds will be on the order of 1000.  Obviously, a run time of 5 min per round will be much too slow to arrive at the solution in a reasonable time.\n\nThe first optimization I investigated was the double-checking for adjacent elves in the code.  For testing purposes, two functions were created with one function, unstored_nbrs, containing the two calculations as used in Part 1 and another function, stored_nbrs, which stores the results from the first check and just pulls the stored result in the second check.  The calculation for adjacent elves itself is slow with a run time of ~35 seconds.  So, eliminating the second calculation cuts the total run time nearly in half.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#From part 1 solution\nunstored_nbrs <- function(elves, nbr) {\n  for (elf in elves) {\n    if (!any(lapply(nbr, function(x) x + elf) %in% elves)) next\n  }\n  for (elf in elves) {\n    if (!any(lapply(nbr, function(x) x + elf) %in% elves)) next\n  }\n}\n\n#Optimization 1 to cut time in about half\nstored_nbrs <- function(elves, nbr) {\n  stored <- list()\n  for (i in 1:length(elves)) {\n    if (!any(lapply(nbr, function(x) x + elves[[i]]) %in% elves)) {\n      stored[[i]] <- TRUE\n      next\n    } else {\n      stored[[i]] <- FALSE\n    }\n  }\n  for (j in 1:length(elves)) {\n    if (stored[[j]]) next    \n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\n  \nbench_vec <- microbenchmark(\n  `stored` <- stored_nbrs(elves, nbr),\n  `unstored` <- unstored_nbrs(elves, nbr),\n  times = 2\n)\n\nbench_vec\n```\n:::\n\n\n\nReducing the total run time per round from 5 min to 4.5 min is nice but still much too slow for calculating 1000 rounds.  I should note that similar code as written for Part 1 in Python runs quite quickly and results can be obtained for Part 2 in a few seconds!  One of the solutions posted online used complex numbers to store the elves' coordinates rather than a numeric vector.  I tried a complex numbers implementation in R and it was a bit slower (5 seconds longer).\n\nFurther analysis showed the ```%in%``` function was the major source of the long run times and is being used multiple times to search for vectors within a long list of vectors.  A major breakthrough was found on a whim by trying ```duplicated``` for this check instead of ```%in%```.  The ```duplicated``` function checks a list for duplicate elements and returns TRUE if the element has already been detected and FALSE is not detected.  I observed that applying ```duplicated``` on the elves list ran almost instantaneously however to check for specific numeric vectors within the elves list requires appending those vectors to the end of the list.  I then take the tail of the returned logical vector containing the checks for these specific vectors.  Surprisingly, the results from a function containing duplicated reduced the run time from ~35 sec to ~0.5 sec.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#function using %in%\ncheck_nbrs <- function(elves, nbr) {\n  for (elf in elves) {\n    if (!any(lapply(nbr, function(x) x + elf) %in% elves)) next\n  }\n}\n\n#analogous function to above using duplicated\ncheck_nbrs_d <- function(elves, nbr) {\n  for (i in 1:length(elves)) {\n    if (!any(tail(duplicated(c(elves, lapply(nbr, function(x) x + elves[[i]]))), 8))) next\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbench_vec <- microbenchmark(\n  `in` <- check_nbrs(elves, nbr),\n  `duplicated` <- check_nbrs_d(elves, nbr),\n  times = 2\n)\n\nbench_vec\n```\n:::\n\n\n\nAt this point, I decided to replace all instances of ```%in%``` with a ```duplicated``` check.  The result was a run time of ~1.5 sec per round which is still quite slow compared to a Python implementation but a more realistic run time for solving this puzzle in a more reasonable time of ~20 min.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niter <- 1\n\nwhile (iter < 5000) {\n\n  #if (iter %% 10 == 1) print(paste(\"Round\", iter, \": \", Sys.time()))\n  ec <- elves\n  \n  for (i in 1:length(elves)) {\n    #optimization with duplicated\n    if (!any(tail(duplicated(c(elves, lapply(nbr, function(x) x + elves[[i]]))), 8))) next\n    \n    for (d in ord) {\n      test <- lapply(lapply(scanmap[[d]], '[', 1:2), function(x) x + elves[[i]])\n      #optimization with duplicated\n      if (!any(tail(duplicated(c(elves, test)), 8))) {\n        ec[i] <- list(c(elves[[i]] + moves[[d]]))\n        break\n      }\n    }\n  }\n\n  #stop if no change\n  if (setequal(elves, ec)) break\n  \n  #replaces the whole need for storing multiple moves to the same position\n  not_dup <- !(duplicated(ec) | rev(duplicated(rev(ec))))\n  #update elves with the new positions\n  elves[not_dup] <- ec[not_dup]\n  #update the order of movement directions\n  ord <- c(ord[2:4], ord[1])\n  \n  iter <- iter + 1\n}\n\niter\n```\n:::\n\n\n\nThe need for storing multiple moves to the same position is eliminated by using two ```duplicated``` checks on the proposed moves in ```ec```, once in the forward direction and once in the reverse direction.  The moves which are not duplicated then are directly replaced in ```ec```.  As can be seen above, the code is much simpler for the implementation in Part 2 as compared with Part 1 and runs dramatically faster.\n\nThe number of rounds before the elves stop moving was determined to be 1029.\n\n## Summary\nThe main learning from the Day 23 puzzle was that the ```%in%``` function runs slowly for lists of numeric vectors.  The run time can be significantly reduced by using ```duplicated```.  This optimization was required to solve Part 2 in a reasonable amount of time in R.  It is also interesting that Python runs so much faster even on non-optimized code for this type of problem.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.2 (2024-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2025-02-14\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.5.57 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P readr       * 2.1.5   2024-01-10 [?] CRAN (R 4.4.2)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.4.2)\n P stringr     * 1.5.1   2023-11-14 [?] CRAN (R 4.4.2)\n\n [1] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/windows/R-4.4/x86_64-w64-mingw32\n [2] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/windows/R-4.4/x86_64-w64-mingw32/6698a5f3\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}