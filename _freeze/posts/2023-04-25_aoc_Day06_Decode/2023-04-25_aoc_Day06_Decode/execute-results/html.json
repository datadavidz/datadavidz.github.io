{
  "hash": "24964a2e8b4336c8a9dc1f3b55c2aab4",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 6: Decoding Signals\"\ndate: 2023-04-25\n---\n\n::: {.cell}\n\n:::\n\n\nFind a start-of-packet marker in a string of characters\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 6. You have a defective communication device that you need to fix in order to communicate with the other elves.  You must write a subroutine to identify a start-of-packet marker in the incoming datastream.\n\n## Loading the input file\n\nThe input file consists of a long, string of characters (4096 characters long).  I used the ```file_read``` function from the ```readr``` package in order to read the whole file directly into a string object.  I then parsed the string by character using the ```str_split``` from the ```stringr``` package as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilepath <- here::here(\"./posts/data/aoc/day06_input.txt\")\nfile_str <- read_file(filepath)\n\nfile_split <- str_split(file_str, boundary(\"character\"))[[1]]\n```\n:::\n\n\n## Finding the start-of-packet marker\n\nThe goal of the first part of the puzzle is to identify the first occurrence of the start-of-packet marker.  This marker is denoted by four characters which are all different.  For example, in the string below:\n\n```\nmjqjpqmgbljsphdztnvjfqwrcgsmlb\n```\n\nThe first time four different characters are detected in the sequence is after the 7th character is received and you have the sequence \"jpqm\".  The goal is to report the number of characters processed before this start-of-packet marker is found in the input data.  The subroutine can be written quite easily by determining the number of unique characters in the 4 character buffer as it traverses the input data string.  There are different ways to handle the first three characters.  The way it is handled below is the buffer is initiated by replicating the first character 3 times.  It could be handled in other ways such as not analyzing for uniqueness until the first four characters are loaded or initialize the buffer with the first four characters and begin the loop at the fifth character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarker_length <- 4\nbuffer <- rep(file_split[1], marker_length-1)\ncposition <- 0\n\nfor (i in 1:length(file_split)) {\n  cposition <- cposition + 1\n  if (length(unique(c(buffer, file_split[i]))) == marker_length) {\n    break\n  } else {\n    buffer <- c(buffer[2:(marker_length-1)], file_split[i])\n  }\n}\n\ncposition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1300\n```\n:::\n:::\n\nIn this case, ```cposition``` gives the number of characters processed before the start-of-packet marker sequence is detected.  The buffer is updated by adding the new character and checking to see if the unique characters is equal to 4.  If equal to 4, the for loop is stopped and ```cposition``` is reported.  If not equal to 4, the first (oldest) character in the buffer is removed and the loop is continued.  For my input data file, 1300 characters are processed before the start-of-packet marker is detected.\n\n## Finding the start-of-message marker\n\nThe goal of the second part of the puzzle is to find the start-of-message marker which is represented by 14 distinct characters instead of the 4 distinct characters from the first part.  Detecting this marker just requires updating the value of the ```marker_length``` to 14 in the code used in part one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarker_length <- 14\nbuffer <- rep(file_split[1], marker_length-1)\ncposition <- 0\n\nfor (i in 1:length(file_split)) {\n  cposition <- cposition + 1\n  if (length(unique(c(buffer, file_split[i]))) == marker_length) {\n    break\n  } else {\n    buffer <- c(buffer[2:(marker_length-1)], file_split[i])\n  }\n}\n\ncposition\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3986\n```\n:::\n:::\n\nFor part two, 3986 characters are processed before the start-of-message marker is detected.  Since the code is reused with only a change in the value of ```marker_length``` a function could be created with an argument to pass any marker length value.  I did not do this step here as the puzzle answers had already been determined.\n\n## Summary\n\nThe Day 6 puzzle was quite straightforward especially with the use of the ```unique``` function in base R.  Functions from ```readr``` and ```stringr``` made it easy to process the input file into the desired character vector.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-05-08\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.2.335 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n   readr       * 2.1.3   2022-10-01 [2] CRAN (R 4.2.1)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpiAoZ4Q/renv-library-2e3455614438\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/Temp/RtmpiAoZ4Q/renv-system-library\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}