{
  "hash": "3e9fa8a36cae612bb705ef572532300b",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 8: Matrices\"\ndate: 2023-05-17\n---\n\n::: {.cell}\n\n:::\n\n\nAssessing a grid of trees by performing positional calculations on a representative matrix\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 8. The elves are searching for an ideal location for their treehouse.  The trees are planted in a grid and the elves have created a map of the tree heights assessed from their quadcopter.\n\n## Loading the input file\n\nThe input file consists of 99 rows each containing 99 numeric digits.  Simply using ```readLines``` function from base R does a fine job of reading each row into a string however, ultimately, we would like to convert the data into a matrix.  The next step is to convert each row (string) into a character vector using the ```str_split_1``` function from the ```stringr``` package and at the same time convert the characters into numeric values.  These numeric values are stored in one, long, numeric vector.  The numeric vector is then shaped into a matrix with 99 rows and 99 columns as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n\nfilepath <- here::here(\"./posts/data/aoc/day08_input.txt\")\nraw_data <- readLines(filepath)\n\n#convert each line into one long numeric vector\nraw_trees <- numeric()\n\nfor (i in 1:length(raw_data)) {\n  raw_trees <- c(raw_trees, as.numeric(str_split_1(raw_data[i], \"\")))\n}\n\n#convert numeric vector to a matrix\ntrees <- matrix(raw_trees, nrow = 99, ncol = 99, byrow = TRUE)\n```\n:::\n\n\n## Part One: Visibility\n\nThe goal of part one is to determine the number of trees which are visible from outside the grid.  All of the trees on the outside edge of the grid are visible.  For the rest of the trees, the tree is visible if all the trees between it and the edge of the grid are shorter than it.  Only the tree in the same row or column are considered when determining if the tree is visible.  If the tree is visible from any direction (i.e. top, bottom, left or right) then it is considered visible.  As an example, a smaller grid is shown below.\n\n```\n30373\n25512\n65332\n33549\n35390\n```\n\nAll of the trees on the outside edge are visible leaving just the inner nine trees to determine.  The top-left 5 is visible from the top and left but not from the bottom or right due to trees of same height blocking visibility.  The top-right 1 is invisible from all directions since all of the trees around it are taller.\n\nA ```check_visibility``` function has been created to check the visibility from each direction and return TRUE if it is visible from any direction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assumes a 99 x99 tree matrix\ncheck_visibility <- function(tree_mat, row_pos, col_pos){\n  if (row_pos == 1 | row_pos == 99 | col_pos == 1 | col_pos == 99) {\n    visibility <- TRUE\n  } else {\n    tree_height <- tree_mat[row_pos, col_pos]\n    north_vis <- tree_height > max(tree_mat[1:(row_pos-1), col_pos])\n    south_vis <- tree_height > max(tree_mat[(row_pos+1):99, col_pos])\n    west_vis <- tree_height > max(tree_mat[row_pos, 1:(col_pos-1)])\n    east_vis <- tree_height > max(tree_mat[row_pos, (col_pos+1):99])\n    \n    visibility <- north_vis | south_vis | west_vis | east_vis\n  }\n  \n    return(visibility)\n}\n```\n:::\n\n\nAll of the trees are then checked using for loops to cycle through all of the tree locations.  The results are stored in a matrix which is initialized with -1 values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvis_mat <- matrix(rep(-1, 99*99), nrow = 99, ncol = 99)\n\nfor (i in 1:99) {\n  for (j in 1:99) {\n    vis_mat[i, j] <- check_visibility(trees, i, j)\n  }\n}\n```\n:::\n\n\nThe total number of trees from outside the grid is determined by a sum of the resulting matrix since TRUE is captured as 1 and FALSE as 0.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(vis_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1805\n```\n:::\n:::\n\n\n## Part Two: Tree Cover\n\nThe elves are now looking for the best place to build their tree house and they like to see a lot of trees.  The number of trees visible in each direction from the prospective tree house location is determined by the number of trees before reaching a tree of same height or taller as the tree at this location.  Trees that are taller at more distant locations are not counted since the tree house has large eaves which prevent viewing them.  Tree house locations on the perimeter will have see 0 trees in at least one direction.\n\nThe total **scenic score** is obtained by multiplying together the number of trees counted in each direction.  For the example given below:\n\n```\n30373\n25512\n65332\n33549\n35390\n```\n\nThe 5 in the middle of the fourth row can see 2 trees to the north, 2 trees to the west, 1 tree to the south and 2 trees to the east.  So, the total scenic score is 2 * 2 * 1 * 2 which equals 8.\n\nFour functions are created to count the number of trees viewed from each direction.  These functions could be perhaps more efficiently put into a single function but I preferred the simplicity over brevity in this case.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlook_north <- function(tree_mat, row_pos, col_pos) {\n  \n  num_trees <- 0\n  if (row_pos == 1) {\n    #num_trees <- 0\n  } else {\n    tree_height <- tree_mat[row_pos, col_pos]\n    for (i in (row_pos-1):1) {\n      if (tree_mat[i, col_pos] >= tree_height){\n        num_trees <- num_trees + 1\n        break\n      } else {\n        num_trees <- num_trees + 1\n      }\n    }\n  }\n  return(num_trees)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlook_south <- function(tree_mat, row_pos, col_pos) {\n  \n  num_trees <- 0\n  if (row_pos == 99) {\n    #num_trees <- 0\n  } else {\n    tree_height <- tree_mat[row_pos, col_pos]\n    for (i in (row_pos+1):99) {\n      if (tree_mat[i, col_pos] >= tree_height){\n        num_trees <- num_trees + 1\n        break\n      } else {\n        num_trees <- num_trees + 1\n      }\n    }\n  }\n  return(num_trees)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlook_west <- function(tree_mat, row_pos, col_pos) {\n  \n  num_trees <- 0\n  if (col_pos == 99) {\n    #num_trees <- 0\n  } else {\n    tree_height <- tree_mat[row_pos, col_pos]\n    for (i in (col_pos+1):99) {\n      if (tree_mat[row_pos, i] >= tree_height){\n        num_trees <- num_trees + 1\n        break\n      } else {\n        num_trees <- num_trees + 1\n      }\n    }\n  }\n  return(num_trees)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlook_east <- function(tree_mat, row_pos, col_pos) {\n  \n  num_trees <- 0\n  if (col_pos == 1) {\n    #num_trees <- 0\n  } else {\n    tree_height <- tree_mat[row_pos, col_pos]\n    for (i in (col_pos-1):1) {\n      if (tree_mat[row_pos, i] >= tree_height){\n        num_trees <- num_trees + 1\n        break\n      } else {\n        num_trees <- num_trees + 1\n      }\n    }\n  }\n  return(num_trees)\n}\n```\n:::\n\n\nEach function returns the number of trees viewed.  The scenic score is calculated using the ```count_trees``` function which utilizes the four functions previously mentioned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_trees <- function(tree_mat, row_pos, col_pos){\n  scenic_score <- \n    look_north(trees, row_pos, col_pos) *\n    look_south(trees, row_pos, col_pos) *\n    look_west(trees, row_pos, col_pos) *\n    look_east(trees, row_pos, col_pos)\n  \n  return(scenic_score)\n}\n```\n:::\n\n\nThe scenic scores are determined by cycling through all of the possible tree house locations.  A matrix initialized with -1 values is used again to store all of the scenic scores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscenic_mat <- matrix(rep(-1, 99*99), nrow = 99, ncol = 99)\n\nfor (i in 1:99) {\n  for (j in 1:99) {\n    scenic_mat[i, j] <- count_trees(trees, i, j)\n  }\n}\n```\n:::\n\n\nThe highest scenic score is obtained by searching for the maximum of the matrix.\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(scenic_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 444528\n```\n:::\n:::\n\n\nAs a bonus, the location for the maximum scenic score can be obtained as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(scenic_mat == max(scenic_mat), arr.ind = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     row col\n[1,]  78  43\n```\n:::\n:::\n\n## Summary\n\nLoading the data into an R matrix enabled straightforward calculations to answer the Day 8 puzzle.  Breaking the calculation into simple functions resulted in very readable and understandable code.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-06-06\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.2.335 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpqwfTxY/renv-library-1c4079f8156e\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/Temp/RtmpqwfTxY/renv-system-library\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}