{
  "hash": "2c4d33fde36c85246b9fb1e8028a2c7c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code Day 22: Monkey Map\"\ndate: 2025-02-07\n---\n\n::: {.cell}\n\n:::\n\n\n\nFind route along a cube-shaped map\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/2022) problem from Day 22. A map is provided consisting of open tiles \".\" and solid walls \"\\#\" as shown below. The goal is the traverse the map using a set of provided instructions which is shown on the last line of the figure below. The instructions consist of alternating list consisting of numbers and letters (only R or L). Each number is the number of steps to take in the current direction. The letter is the direction to turn where R is to turn 90 degrees clockwise from your current direction and L is to turn 90 degrees counter-clockwise from your current direction.\n\n```         \n        ...#\n        .#..\n        #...\n        ....\n...#.......#\n........#...\n..#....#....\n..........#.\n        ...#....\n        .....#..\n        .#......\n        ......#.\n\n10R5L5R10L4R5L5\n```\n\n## Loading the input file\n\nThe input file begins with the map followed by a blank line and then a line containing the instructions similar to what is shown in the example above. The `read_lines` function from the `readr` package is used to read the input file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(purrr)\n\noptions(scipen = 999)\n\nfilepath <- here::here(\"./posts/data/aoc/day22_input.txt\")\n#filepath <- here::here(\"./posts/data/aoc/day22_test.txt\")\n\ninput_map <- read_lines(filepath, skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Constructing the map\n\nThe end of the map is followed by a blank line. The first command identifies this location. The next set of commands extracts the map lines and calculates the size of the map grid in a matrix. The map_path or set of instructions is then extracted. The matrix for the map is then created by merging the data from each input line.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Setup the map\nblank_line <- (map(input_map, \\(x) nchar(x)) ) |> unlist() |> list(. = _) |> with(which(. == 0))\nmap_grid <- input_map[1:(blank_line-1)]\nmap_nrow <- length(map_grid)\nmap_ncol <- map(map_grid, \\(x) nchar(x)) |> unlist() |> max()\nmap_path <- input_map[(blank_line+1):length(input_map)]\n\n#Create the map\nm <- matrix(data = rep(\" \", map_nrow * map_ncol), nrow = map_nrow, ncol = map_ncol)\n\nfor (i in 1:nrow(m)) {\n  row_data <- str_split_1(map_grid[i], \"\")\n  m[i, 1:length(row_data)] <- row_data\n}\n```\n:::\n\n\n\n## Part 1 Solution\n\nThe goal for Part 1 is to find the ending location after following the instructions provided. The first step is to find the starting location which is the upper-leftmost open tile by skipping any leading empty spaces on the map.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Find starting point on map\nr <- 1\nc <- 1\nd <- list(r = 0, c = 1)\n#dr <- 0\n#dc <- 1\n\nwhile (m[r, c] != \".\") {\n  c <- c + 1\n}\n```\n:::\n\n\n\nThe instructions are parsed and iterated until the end. A regular expression is used to extract each number and letter pair. The steps (x) are not counted in areas with empty spaces and the map wraps around when the open tiles are exceeded in a given direction. The steps continue until reaching the desired number or until a wall is reached. At this point the change in direction (y) is applied.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (a in unlist(str_extract_all(map_path, \"\\\\d+[RL]?\"))) {\n  x <- as.integer(str_extract(a, \"\\\\d+\"))\n  y <- str_extract(a, \"[RL]\")\n  for (i in 1:x) {\n    #n is for next row and column\n    n <- list(r = r, c = c)\n    #get out of the map void\n    while (TRUE) {\n      n$r <- ifelse((n$r + d$r) %% map_nrow == 0, map_nrow, (n$r + d$r) %% map_nrow)\n      n$c <- ifelse((n$c + d$c) %% map_ncol == 0, map_ncol, (n$c + d$c) %% map_ncol)\n      if (m[n$r, n$c] != \" \") break\n    }\n    if (m[n$r, n$c] == \"#\") break\n    r <- n$r\n    c <- n$c\n  }\n  if (is.na(y)) {\n    next\n  } else if (y == \"R\") {\n    d <- list(r = d$c, c = -d$r)\n  } else if (y == \"L\") {\n    d <- list(r = -d$c, c = d$r)\n  }\n}\n\nprint(paste(r, c, d$r, d$c))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"190 16 0 -1\"\n```\n\n\n:::\n:::\n\n\n\nFor the input file, the ending location is on row 190 and column 16. The ending direction is -1 in the column direction which is left. The final score is calculated as the row position multiplied by 1000 plus the column position multiplied by 4 plus the direction score (0 for right, 1 for down, 2 for left, 3 for up).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#scoring for different directions as specified by the puzzle\ncalc_score <- function(r, c, d) {\n  if (d$r == 0 & d$c == 1) {\n    dir_score <- 0\n  } else if (d$r == 1 & d$c == 0) {\n    dir_score <- 1\n  } else if (d$r == 0 & d$c == -1) {\n    dir_score <- 2\n  } else {\n    dir_score <- 3\n  }\n\n  #apply final scoring calculation\n  return(1000 * r + 4 * c  + dir_score)\n}\n```\n:::\n\n\n\nThe puzzle solution for Part 1 was 190066.\n\n## Part 2 Solution\n\nIn part 2, it is revealed that the map is not a flat, 2-D map but rather is a representation of a 3-D cube. This is shown in the figure below where the connected corners are labeled with numbers and like numbers form a corner of the cube. A scale for the row and column numbers are also provided.\n\n![Schematic of the cube with like corners labeled](CubeLayout.png) The change in the code to accommodate the cube is quite tedious. You need to figure out how the edges align to figure out the new location after you crossover from one cube face to the next. This is accomplished through a series of if-else statements to handle each case and provide the new location and direction on the map. The good news is that you no longer need to worry about any \"void\" spaces. The current direction is also stored in case a wall is encountered during this movement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#find starting point on map\nr <- 1\nc <- 1\nd <- list(r = 0, c = 1)\n\nwhile (m[r, c] != \".\") {\n  c <- c + 1\n}\n\nfor (a in unlist(str_extract_all(map_path, \"\\\\d+[RL]?\"))) {\n  #number of steps\n  x <- as.integer(str_extract(a, \"\\\\d+\"))\n  #direction change\n  y <- str_extract(a, \"[RL]\")\n  for (i in 1:x) {\n    n <- list(r = r + d$r, c = c + d$c)\n    #cache dr and dc\n    cache <- list(dr = d$r, dc = d$c)\n    #Handle all the cases of moving from one cube face to another\n    #case of up 1-5\n    if (n$r < 1 & n$c > 50 & n$c <= 100 & d$r == -1){\n      d <- list(r = 0, c = 1)\n      n <- list(r = n$c + 100, c = 1)\n    #case of left 1-5\n    } else if (n$c < 1 & n$r > 150 & n$r <= 200 & d$c == -1) {\n      d <- list(r = 1, c = 0)\n      n <- list(r = 1, c = n$r - 100)\n    #case of up 3-5\n    } else if (n$r < 1 & n$c > 100 & n$c <= 150 & d$r == -1) {\n      n <- list(r = 200, c = n$c - 100)\n    #case of down 3-5\n    } else if (n$r > 200 & n$c > 0 & n$c <= 50 & d$r == 1) {\n      n <- list(r = 1, c = n$c + 100)\n    #case of right 3-4\n    } else if (n$c > 150 & n$r > 0 & n$r <= 50 & d$c == 1) {\n      d$c <- -1\n      n <- list(r = 151 - n$r, c = 100)\n    #case of right 4-3\n    } else if (n$c > 100 & n$r > 100 & n$r <= 150 & d$c == 1) {\n      d$c <- -1\n      n <- list(r = 151 - n$r, c = 150)\n    #case of 4 down\n    } else if (n$r > 50 & n$c > 100 & n$c <= 150 & d$r == 1) {\n      d <- list(r = 0, c = -1)\n      n <- list(r = n$c - 50, c = 100)\n    #case of 4 right\n    } else if (n$c > 100 & n$r > 50 & n$r <= 100 & d$c == 1) {\n      d <- list(r = -1, c = 0)\n      n <- list(r = 50, c = n$r + 50)\n    #case of 3 down\n    } else if (n$r > 150 & n$c > 50 & n$c <= 100 & d$r == 1) {\n      d <- list(r = 0, c = -1)\n      n <- list(r = n$c + 100, c = 50)\n    #case of 3 right\n    } else if (n$c > 50 & n$r > 150 & n$r <= 200 & d$c == 1) {\n      d <- list(r = -1, c = 0)\n      n <- list(r = 150, c = n$r - 100)\n    #case of 2 up\n    } else if (n$r < 101 & n$c > 0 & n$c <= 50 & d$r == -1) {\n      d <- list(r = 0, c = 1)\n      n <- list(r = n$c + 50, c = 51)\n    #case of 2 left\n    } else if (n$c < 51 & n$r > 50 & n$r <= 100 & d$c == -1) {\n      d <- list(r = 1, c = 0)\n      n <- list(r = 101, c = n$r - 50)\n    #case of left 1-2\n    } else if (n$c < 51 & n$r > 0 & n$r <= 50 & d$c == -1) {\n      d <- list(r = 0, c = 1)\n      n <- list(r = 151 - n$r, c = 1)\n    #case of left 2-1\n    } else if (n$c < 1 & n$r > 100 & n$r <= 150 & d$c == -1) {\n      d <- list(r = 0, c = 1)\n      n <- list(r = 151 - n$r, c = 51)\n    }\n    #Revert direction if encountering a wall\n    if (m[n$r, n$c] == \"#\") {\n      d <- list(r = cache$dr, c = cache$dc)\n      break\n    } \n    r <- n$r\n    c <- n$c\n  }\n  #apply the direction change\n  if (is.na(y)) {\n    next\n  } else if (y == \"R\") {\n    d <- list(r = d$c, c = -d$r)\n  } else if (y == \"L\") {\n    d <- list(r = -d$c, c = d$r)\n  }\n}\n\nprint(paste(r, c, d$r, d$c))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"134 42 0 -1\"\n```\n\n\n:::\n:::\n\n\n\nThe final location for Part 2 is row 134 and column 42 and facing up for a puzzle score of 134170.\n\n## Summary\nThe day 22 puzzle was straightforward after figuring out how to code all of the rules for traversing the map.  I performed double-assignments using a list in order to make more compact code in handling the direction and next position variables (d and n).  Double-assignment also helped in avoiding the creation of temporary variables to store values as values for rows and columns were exchanged.  In Python, double assignment is \"built-in\" but in R you need to use a list.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.2 (2024-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2025-02-07\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.5.57 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P purrr       * 1.0.2   2023-08-10 [?] CRAN (R 4.4.2)\n P readr       * 2.1.5   2024-01-10 [?] CRAN (R 4.4.2)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.4.2)\n P stringr     * 1.5.1   2023-11-14 [?] CRAN (R 4.4.2)\n\n [1] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/windows/R-4.4/x86_64-w64-mingw32\n [2] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/windows/R-4.4/x86_64-w64-mingw32/6698a5f3\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}