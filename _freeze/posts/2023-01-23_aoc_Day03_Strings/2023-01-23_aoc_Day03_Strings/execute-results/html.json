{
  "hash": "77046ce50ff457ef19331ee843ec15ac",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 3: Manipulating Strings\"\ndate: 2023-01-23\n---\n\n::: {.cell}\n\n:::\n\nLists of elf items are contained within strings which are manipulated with the ```stringr``` package to determine loading priorities.\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 3.  This time the elves need to load items into rucksacks and the list of items is represented by strings such as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nfilepath <- here::here(\"./posts/data/aoc/day03_input.txt\")\n\ndata <- read_delim(filepath, delim = \"\\n\", col_names = c(\"items\"))\ndata |> slice(1:5)\n```\n:::\n\n\nEach character in each string represents an item.  The first half of the items in the string go into the first compartment and the second half of the items go into the second compartment.  The item which is in both the first half and second half of the string sets the priority where:\n\nThe lowercase letters from a to z have priorities 1 through 26.  \nThe uppercase letters from A to Z have priorities 27 through 52.  \n\nThis priority table is rather easily defined in R using the ```letters``` constant for lowercase a-z and ```LETTERS``` for uppercase A-Z.\n\n::: {.cell}\n\n```{.r .cell-code}\nitem_priority <- tibble(item_name = c(letters, LETTERS),\n                        item_prio = 1:52)\n```\n:::\n\n\n## Solution to Part One\n\nThe goal of part one is to determine the sum of the priorities for all of the item lists.  Again, the priority is defined by the common item in the first and second half of the string.  The first step is to separate each string into two halves.  The midpoint is determined by dividing the string length by 2.  Functions from the ```stringr``` package are used to find the string length (```str_length```) and then create the sub-strings (```str_sub```).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_data <- data |>\n  mutate(item_len = str_length(items)) |>\n  rowwise() |>\n  mutate(items_1 = str_sub(items, 1, item_len / 2)) |>\n  mutate(items_2 = str_sub(items, (item_len / 2) + 1, item_len)) |>\n  ungroup()\n\nhead(split_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  items                                            item_len items_1      items_2\n  <chr>                                               <int> <chr>        <chr>  \n1 zBBtHnnHtwwHplmlRlzPLCpp                               24 zBBtHnnHtwwH plmlRl…\n2 vvhJccJFGFcNsdNNJbhJsJQplQMRLQMlfdfTPCLfQQCT           44 vvhJccJFGFc… QplQMR…\n3 GPhjcjhZDjWtnSVH                                       16 GPhjcjhZ     DjWtnS…\n4 BNhHVhrGNVTbDHdDJdJRPJdSQQSJwPjR                       32 BNhHVhrGNVT… JdJRPJ…\n5 lvtsfbsqzwSnJcvjSm                                     18 lvtsfbsqz    wSnJcv…\n6 MftttFLftZMLgtgMbltMqZzbDNrTpVGhNWrDTrpTGNpZGZhD       48 MftttFLftZM… DNrTpV…\n```\n:::\n:::\n\nThe common item in both compartments is identified by using two more ```stringr``` package functions.  The ```str_split``` function is used to create a list of the characters in each sub-string.  The ```str_unique``` function (new to ```stringr``` 1.5.0) is used to create a list of only the unique characters in the substring.  Finally, the ```intersect``` function from ```dplyr``` is used to find the common character is both lists.\n\n::: {.cell}\n\n```{.r .cell-code}\ncommon_items <- split_data |>  \n  rowwise() |>\n  mutate(split_1 = str_split(items_1, \"\")) |>\n  mutate(split_2 = str_split(items_2, \"\")) |>\n  mutate(unique_1 = list(str_unique(unlist(split_1)))) |>\n  mutate(unique_2 = list(str_unique(unlist(split_2)))) |>\n  mutate(common_item = intersect(unique_1, unique_2)) |>\n  ungroup() |>\n  select(items_1, items_2, common_item)\n\ncommon_items |> slice(1:6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  items_1                  items_2                  common_item\n  <chr>                    <chr>                    <chr>      \n1 zBBtHnnHtwwH             plmlRlzPLCpp             z          \n2 vvhJccJFGFcNsdNNJbhJsJ   QplQMRLQMlfdfTPCLfQQCT   d          \n3 GPhjcjhZ                 DjWtnSVH                 j          \n4 BNhHVhrGNVTbDHdD         JdJRPJdSQQSJwPjR         d          \n5 lvtsfbsqz                wSnJcvjSm                v          \n6 MftttFLftZMLgtgMbltMqZzb DNrTpVGhNWrDTrpTGNpZGZhD Z          \n```\n:::\n:::\n\n\nThe common_items are then joined with ```item_priority``` and then the priorities are summed to find the total priority. \n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(common_items, item_priority, by = c(\"common_item\" = \"item_name\")) %>%\n  summarize(total_priority = sum(item_prio))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  total_priority\n           <int>\n1           7597\n```\n:::\n:::\n\n## Solution to Part Two\n\nIn Part Two, we are informed that each elf is part of group consisting of three elves and each group has an identifying badge. Every set of three lines in the dataset represents one group and the common item among all three lines is the badge.  Priorities for the items are the same as defined in Part One where a-z is 1 to 26 and A-Z is 27 to 52.  The question is what is the sum of the priorities for the group badges.\n\nIn this case, we do not need to split the strings in half but we do need to identify the unique characters in each string similar to Part One.\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_data <- data |>\n  rowwise() |>\n  mutate(items_split = str_split(items, \"\")) |>\n  mutate(items_unique = list(str_unique(unlist(items_split)))) |>\n  ungroup()\n\nunique_data |> slice(1:6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  items                                            items_split items_unique\n  <chr>                                            <list>      <list>      \n1 zBBtHnnHtwwHplmlRlzPLCpp                         <chr [24]>  <chr [13]>  \n2 vvhJccJFGFcNsdNNJbhJsJQplQMRLQMlfdfTPCLfQQCT     <chr [44]>  <chr [20]>  \n3 GPhjcjhZDjWtnSVH                                 <chr [16]>  <chr [13]>  \n4 BNhHVhrGNVTbDHdDJdJRPJdSQQSJwPjR                 <chr [32]>  <chr [18]>  \n5 lvtsfbsqzwSnJcvjSm                               <chr [18]>  <chr [15]>  \n6 MftttFLftZMLgtgMbltMqZzbDNrTpVGhNWrDTrpTGNpZGZhD <chr [48]>  <chr [20]>  \n```\n:::\n:::\n\n\nNow we need to identify the groups by introducing a new id column, ```elf_group```, for each set of three lines.  We then ```group_by``` this new column and find the intersection between the first two lines and the result is intersected with the last line to find the common item.  The ```Reduce``` function is used to iteratively apply the function with two arguments at a time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbadge_data <- unique_data |>\n  mutate(elf_group = rep(1:(nrow(data) %/% 3), each = 3)) |>\n  mutate(elf_group = as.factor(elf_group)) |>\n  group_by(elf_group) |>\n  summarize(badge = Reduce(intersect, items_unique), .groups = \"drop\")\n\nbadge_data |> slice(1:6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  elf_group badge\n  <fct>     <chr>\n1 1         P    \n2 2         b    \n3 3         Z    \n4 4         S    \n5 5         q    \n6 6         c    \n```\n:::\n:::\n\n\nThe total priority for the badge items is then calculated by joining with ```item_priority```.\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(badge_data, item_priority, by = c(\"badge\" = \"item_name\")) %>%\n  summarize(total_priority = sum(item_prio))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  total_priority\n           <int>\n1           2607\n```\n:::\n:::\n\n## Summary\n\nThis Advent of Code problem provided a great opportunity to brush up on some useful ```stringr``` functions.  It was also interesting to keep all of the data transformations in tibble columns.  A nice application of the ```Reduce``` function (base R!) was used to find the common item among several strings.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2023-02-02\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.2.269 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P dplyr       * 1.0.10  2022-09-01 [?] CRAN (R 4.2.2)\n P forcats     * 0.5.2   2022-08-19 [?] CRAN (R 4.2.2)\n P ggplot2     * 3.3.6   2022-05-03 [?] CRAN (R 4.2.1)\n   purrr       * 0.3.5   2022-10-06 [2] CRAN (R 4.2.1)\n   readr       * 2.1.3   2022-10-01 [2] CRAN (R 4.2.1)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.2.1)\n P stringr     * 1.5.0   2022-12-02 [?] CRAN (R 4.2.2)\n P tibble      * 3.1.8   2022-07-22 [?] CRAN (R 4.2.1)\n   tidyr       * 1.2.1   2022-09-08 [2] CRAN (R 4.2.1)\n P tidyverse   * 1.3.2   2022-07-18 [?] CRAN (R 4.2.1)\n\n [1] C:/Users/David Zoller/AppData/Local/Temp/RtmpUHj1Wl/renv-library-24087b9d1284\n [2] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.2/x86_64-w64-mingw32\n [3] C:/Users/David Zoller/AppData/Local/Temp/RtmpUHj1Wl/renv-system-library\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}