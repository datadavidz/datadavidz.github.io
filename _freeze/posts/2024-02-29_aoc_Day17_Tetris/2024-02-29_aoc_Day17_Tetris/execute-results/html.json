{
  "hash": "80700dd28b085da628a34626ec570c6c",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code Day 16: BitOps and Hashtables\"\ndate: 2024-02-29\n---\n\n::: {.cell}\n\n:::\n\n\nSimulating falling rocks with different shapes (similar to the game Tetris)\n\n## Introduction\n\nThis post explains my solution to the [Advent of Code](http://adventofcode.com/) problem from Day 17.  You arrive in a tall, narrow cavern with different shape rocks falling down.  If you can't figure out which rocks will drop next, you will be crushed.  The rocks have the following shapes (with '#' meaning rock and a '.' meaning a space:\n\n```\n####\n\n.#.\n###\n.#.\n\n..#\n..#\n###\n\n#\n#\n#\n#\n\n##\n##\n```\n\nThe rocks fall in the order as shown from top to bottom. After the fifth rock has fallen, the sequence starts again in the same order.  The rocks are pushed left or right by jets of gas coming from the cavern walls.  The jets follow a sequence as shown below.\n\n```\n>>><<><>><<<>><>>><<<>>><<<><<<>><>><<>>\n```\n\nA '>' means the gas jet pushes the rock to the right and a '<' means the gas jet pushes the rock to the right.  Once the end is reached, the sequence starts over again starting at the beginning.  The cavern is exactly 7 units wide.  A rock appears so that its left edge is two units away from the left cavern wall and 3 units from the highest rock (or the floor if no rocks have dropped).  After the rock appears, it alternates between being pushed by a gas jet and then falling one unit down.  If the rock is blocked from moving left or right due to another rock or the cavern wall, the rock stays at its current location.  If the rock is blocked from moving down due to another rock or the cavern floor, the rock becomes fixed at its current location and part of a solid rock structure in the cavern.  Once the rock becomes fixed, a new rock appears at the top of the cavern.\n\nThe goal is to determine the height of the solid rock structure in the cavern after a specific number of rocks have fallen.  In Part One, you need to determine the height after 2022 rocks have fallen.  In Part Two, you need to determine the height after one trillion rocks have fallen.\n\n## Loading the input file\n\nThe input file contains only the jet sequence which is a single string made up of '>' and '<' characters.  The input file is much longer than in the example shown above.  The string is split into an array of single characters using the ```str_split_1``` function from the ```stringr``` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\nlibrary(stringr)\nlibrary(purrr)\n\nfilepath <- here::here(\"./posts/data/aoc/day17_input.txt\")\n#filepath <- here::here(\"./posts/data/aoc/day17_test.txt\")\n\ninput_jet <- read_lines(filepath, skip_empty_rows = TRUE)\ninput_jet <- str_trim(input_jet) |> str_split_1(\"\")\n\nlength(input_jet)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10091\n```\n:::\n:::\n\nAt first, I tried representing the rocks using the characters as shown however this became overly complex programmatically.  The better way to represent the rocks is numerically according to the x and y coordinates.  A further optimization can be realized if you use complex numbers where the real part represents the x coordinate and the imaginary part represents the y coordinate.  I learned this from the Day 17 solution posted by [hyper neutrino](https://github.com/hyper-neutrino/advent-of-code).  In fact, much of the solution presented below is based upon his Python implementation.  The five types of rocks represented as complex numbers are shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrocks <- list(\n  c(0, 1, 2, 3),\n  c(1, 1i, 1+1i, 2+1i, 1+2i),\n  c(0, 1, 2, 2+1i, 2+2i),\n  c(0, 1i, 2i, 3i),\n  c(0, 1, 1i, 1+1i)\n)\n```\n:::\n\n\nThe jet sequence is also best represented numerically which can be accomplished with a single line of code.  A '>' or shift to the right is changed to a 1 and a '<' or shift to the left is change to a -1.  The ```map_int``` function from the ```purrr``` package is used to transform the character array into a numerical list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njets <- map_int(input_jet, \\(x) ifelse(x == \">\", 1, -1))\n```\n:::\n\n\n## Part One\n\nNow, we need to determine the height of the solid rock structure after 2022 rocks have dropped into the cavern.  The cavern floor and first rock are initialized.  The rock position is then first updated based on the gas jet and then updated based on dropping one unit down.  The set of map functions from the purrr package are used extensively to update the rock coordinates in a concise way.  The list containing the solid structure is occasionally updated to just the top 200 coordinates in order to optimize the speed of execution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# initialize the solid as the cavern floor\nsolid <- map(0:6, \\(x) x-1i)\n\nheight <- 0\nrc <- 0 #rock count\nri <- 0 #rock index\nlim <- 200 #limit the amount of data stored for the solid\n\n# update position of the first rock\nrock <- map(rocks[[ri+1]], \\(x) x + 2 + (height + 3) * 1i)\n\nwhile (rc < 2022) {\n  for (jet in jets) {\n\n    # update the rock position due to the gas jet\n    moved <- map(rock, \\(x) x + jet)\n    blocked <- any(moved %in% solid)\n    if (all(map_lgl(moved, \\(x) (Re(x) < 7) & (Re(x) >= 0))) & !blocked) {\n      rock <- moved\n    }\n    # update the rock position to drop one unit\n    moved <- map(rock, \\(x) x - 1i)\n    # if the rock is blocked from moving down then it becomes part of the solid\n    if (any(moved %in% solid)) {\n      solid <- c(solid, rock[!(rock %in% solid)])\n      rc <- rc + 1\n      height <- max(map_vec(solid, \\(x) Im(x))) + 1\n      if (rc >= 2022) break\n      ri <- (ri + 1) %% 5\n      rock <- map(rocks[[ri+1]], \\(x) x + 2 + (height + 3) * 1i)\n    } else {\n      # if rock is not blocked then update the position\n      rock <- moved\n    }\n    # keep the solid list from taking up too much memory\n    if (length(solid) > lim) solid <- solid[(length(solid)-(lim+1)):length(solid)]\n  }\n}\n\nheight\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3117\n```\n:::\n:::\n\nAfter 2022 rocks have fallen, the height of the solid rock structure is 3117 units.\n\n## Part Two\n\nApparently, the elephants are not impressed by the simulation of 2022 rocks and want to see the results after dropping a trillion rocks.  Of course, executing the same loop for a trillion rocks would take much too long so we need to find a shortcut.  The shortcut is to look for a repeating sequence as the rocks are dropped.  To find the start of the repeating sequence, we are looking for three conditions to be met: the jet index, the rock index and the top of the solid rock structure are the same values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolid <- map(0:6, \\(x) x-1i)\nheight <- 0\nnumblock <- 1e12\n\n# store the rock count and height at each jet index, rock index and top of solid\nseen <- list()\n\n# summarize the top of the solid rock structure\nsummarize_solid <- function() {\n  o <- rep(-20, 7)\n  for (x in solid) {\n    r <- Re(x)\n    i <- Im(x)\n    o[r+1] <- max(o[r+1], i)\n  }\n  top <- max(o)\n  return(map_int(o, \\(x) x - top))\n}\n\nrc <- 0\nri <- 0\nlim <- 200\nrock <- map(rocks[[ri+1]], \\(x) x + 2 + (height + 3) * 1i)\n\nwhile (rc < numblock) {\n  for (ji in seq_along(jets)) {\n    jet <- jets[ji]\n    moved <- map(rock, \\(x) x + jet)\n    blocked <- any(moved %in% solid)\n    if (all(map_lgl(moved, \\(x) (Re(x) < 7) & (Re(x) >= 0))) & !blocked) {\n      rock <- moved\n    }\n    moved <- map(rock, \\(x) x - 1i)\n    if (any(moved %in% solid)) {\n      solid <- c(solid, rock[!(rock %in% solid)])\n      rc <- rc + 1\n      height <- max(map_vec(solid, \\(x) Im(x))) + 1\n      if (rc >= numblock) break\n      ri <- (ri + 1) %% 5\n      rock <- map(rocks[[ri+1]], \\(x) x + 2 + (height + 3) * 1i)\n      # create a key with the jet index, rock index and top of the solid\n      key <- paste0(ji, ri, paste(summarize_solid(), collapse = ''))\n      # if the key has been seen before, calculate the offset\n      if (key %in% names(seen)) {\n        lrc <- seen[[key]][1] #last rock count\n        lh <- seen[[key]][2]  #last height\n        rem <- numblock - rc  #remainder of rocks left\n        rep <- floor(rem / (rc - lrc)) # number of repetitions of the same sequence\n        offset <- rep * (height - lh)  # amount to add to the height due to repeats\n        rc <- rc + (rep * (rc - lrc))  # update the rock count\n        seen <- list()                 # clear the seen list\n      }\n      seen[[key]] <- c(rc, height)\n    } else {\n      rock <- moved\n    }\n    if (length(solid) > lim) solid <- solid[(length(solid)-(lim+1)):length(solid)]\n  }\n}\n\nformat(height + offset, scientific = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1553314121019\"\n```\n:::\n:::\n\nUsing the shortcut of finding the repeating sequence enables finding the height of 1553314121019 units for a trillion blocks in a little over a minute!  The rocks are iterated until the repeat is found, the rock count is jumped ahead for the number of repeats that can occur without exceeding one trillion rocks and then the rocks are iterated until one trillion rocks are dropped.\n\n## Summary\n\nThe simulation of dropping a sequence of rocks into a cavern was successfully executed in R for one trillion rocks.  Some nice optimizations were implemented to have concise code which executes relatively quickly.  It helped to represent the rock coordinates as complex numbers.  The map functions from the ```purrr``` package enabled concise code.  The shortcut to find a repeating sequence using a named list in a manner analogous to a Python dictionary was the key to completing Part Two.\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2024-03-01\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.450 @ C:\\\\PROGRA~1\\\\RStudio\\\\RESOUR~1\\\\app\\\\bin\\\\quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P purrr       * 1.0.2   2023-08-10 [?] CRAN (R 4.3.2)\n P readr       * 2.1.5   2024-01-10 [?] CRAN (R 4.3.2)\n P sessioninfo * 1.2.2   2021-12-06 [?] CRAN (R 4.3.2)\n P stringr     * 1.5.1   2023-11-14 [?] CRAN (R 4.3.2)\n\n [1] C:/Users/David Zoller/Documents/datadavidz.github.io/renv/library/R-4.3/x86_64-w64-mingw32\n [2] C:/Users/David Zoller/AppData/Local/R/cache/R/renv/sandbox/R-4.3/x86_64-w64-mingw32/7f66d5b3\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}